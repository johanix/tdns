# HPKE-Based DNSSEC Key Distribution Infrastructure

## Overview

This document describes the design and implementation of an HPKE (Hybrid Public Key Encryption) based distribution infrastructure for DNSSEC private keys, specifically ZSK keys, from a central Key Management System (KMS) to multiple edge authoritative servers.

## Architecture

### Components

1. **tdns-kdc** (Key Distribution Center)
   - Central key management and distribution daemon
   - Generates DNSSEC ZSK keys
   - Manages HPKE keypairs for edge nodes
   - Publishes control information in DNS control zone (KMCTRL RRs)
   - Responds to KMREQ queries with encrypted KMPKG responses
   - Handles rapid ZSK rollover scenarios
   - **Database**: MariaDB (not SQLite) for production-grade reliability

2. **tdns-auth** (Edge Authoritative Server)
   - Receives NOTIFY from KDC
   - Queries control zone for KMCTRL records
   - Generates ephemeral HPKE keypair
   - Sends KMREQ query directly to KDC (no caching)
   - Receives and decrypts KMPKG responses
   - Injects keys into local KeyDB
   - Implements heartbeat/license-to-sign mechanism (future)

### Transport: DNS-Only

**Key Design Principle**: All communication uses DNS protocol exclusively - no separate API endpoints.

This approach:
- Leverages existing DNS infrastructure
- Uses DNS's built-in security (SIG(0))
- Fits naturally into DNS operations
- No additional network protocols needed
- Can use existing DNS transport mechanisms (Do53, DoT, DoH, DoQ)

### Key Concepts

#### HPKE Configuration
- **Mode**: Base (no sender authentication required)
- **KEM**: X25519 (Elliptic Curve Diffie-Hellman over Curve25519)
- **KDF**: HKDF-SHA256
- **AEAD**: AES-256-GCM

#### Key Types

1. **Long-term HPKE Keypair** (per edge node)
   - Generated once during edge node registration
   - Public key manually configured at KDC
   - Private key stored securely on edge node
   - Used for establishing secure channel

2. **Ephemeral HPKE Keypair** (per transaction)
   - Generated by edge node for each key update request
   - Provides forward secrecy
   - Public key sent to KDC via EDNS(0) option
   - Discarded after transaction completes

3. **DNSSEC ZSK Keys**
   - Generated by KDC
   - Private keys encrypted with HPKE before distribution
   - State: created → published → active → retired

## Data Flow

### Initial Setup

1. Edge node generates long-term HPKE keypair
2. Edge node public key manually registered at KDC
3. Edge node private key stored securely (eventually in-memory only)
4. KDC publishes control zone (e.g., `kdc.example.com`)

### Key Distribution Flow (DNS-Based)

1. **KDC → Edge**: NOTIFY
   - KDC sends DNS NOTIFY to edge nodes when new keys are available
   - NOTIFY includes control zone name

2. **Edge → KDC**: Query KMCTRL records
   - Edge queries control zone for KMCTRL records
   - KMCTRL contains: zone names, distribution IDs, key IDs, timestamps

3. **Edge → KDC**: KMREQ query (direct, no caching)
   - Edge generates ephemeral HPKE keypair
   - Edge constructs KMREQ query:
     - QNAME: encodes zone name, distribution ID, and ephemeral public key
     - EDNS(0) option: ephemeral public key (alternative/additional)
     - SIG(0): authenticates edge to KDC using long-term keypair
   - Query sent directly to KDC (CD=1, RD=0, no recursion)

4. **KDC → Edge**: KMPKG response
   - KDC validates SIG(0) signature
   - KDC extracts ephemeral public key from KMREQ
   - KDC encrypts ZSK private keys using HPKE:
     - Recipient: Edge's long-term public key (for authentication)
     - Ephemeral: Edge's ephemeral public key (for forward secrecy)
   - KDC returns KMPKG RR(s) containing encrypted key material

5. **Edge**: Decrypt and inject
   - Edge decrypts KMPKG using long-term + ephemeral private keys
   - Validates key material
   - Injects into KeyDB with appropriate state

### Rapid ZSK Rollover (Compromise Scenario)

1. KDC detects compromised edge node (manual trigger or automated)
2. KDC immediately distributes standby ZSK private key to all other edge nodes
3. Compromised edge node excluded from distribution
4. All non-compromised edges activate standby ZSK
5. Compromised edge loses access to signing keys

## Database Schema

### KDC Side: MariaDB Tables

```sql
-- HPKE keystore for edge nodes
CREATE TABLE IF NOT EXISTS hpke_keystore (
  id              INT AUTO_INCREMENT PRIMARY KEY,
  edge_id         VARCHAR(255) NOT NULL,           -- Unique identifier for edge node
  longterm_pubkey TEXT NOT NULL,                  -- Base64-encoded HPKE public key
  registered_at   TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  last_seen       TIMESTAMP NULL,
  status          ENUM('active', 'revoked', 'suspended') DEFAULT 'active',
  comment         TEXT,
  UNIQUE KEY uk_edge_id (edge_id),
  INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- Control zone records (KMCTRL)
CREATE TABLE IF NOT EXISTS kmctrl_records (
  id              INT AUTO_INCREMENT PRIMARY KEY,
  zone            VARCHAR(255) NOT NULL,          -- Zone name needing keys
  distribution_id VARCHAR(64) NOT NULL,          -- Unique ID for this distribution
  keyid           INT NOT NULL,                   -- DNSSEC key ID
  key_state       ENUM('published', 'active', 'standby') NOT NULL,
  created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  expires_at      TIMESTAMP NULL,                 -- Optional expiration
  status          ENUM('pending', 'active', 'revoked') DEFAULT 'pending',
  UNIQUE KEY uk_distribution (distribution_id),
  INDEX idx_zone (zone),
  INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- Distributed keys (encrypted packages)
CREATE TABLE IF NOT EXISTS distributed_keys (
  id              INT AUTO_INCREMENT PRIMARY KEY,
  zone            VARCHAR(255) NOT NULL,
  keyid           INT NOT NULL,
  edge_id         VARCHAR(255) NULL,             -- NULL = distributed to all edges
  encrypted_key    BLOB NOT NULL,                 -- HPKE-encrypted private key
  distribution_id VARCHAR(64) NOT NULL,
  created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  expires_at      TIMESTAMP NULL,
  status          ENUM('pending', 'delivered', 'active', 'revoked') DEFAULT 'pending',
  FOREIGN KEY (edge_id) REFERENCES hpke_keystore(edge_id) ON DELETE CASCADE,
  INDEX idx_distribution (distribution_id),
  INDEX idx_zone_keyid (zone, keyid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### Edge Side: SQLite (existing KeyDB)

```sql
-- Add to existing KeyDB schema
CREATE TABLE IF NOT EXISTS 'HpkeKeys' (
  id              INTEGER PRIMARY KEY,
  edge_id         TEXT,           -- This edge's identifier
  longterm_privkey TEXT,           -- Encrypted at rest (future: in-memory only)
  kdc_control_zone TEXT,          -- KDC control zone name (e.g., "kdc.example.com")
  kdc_address     TEXT,            -- KDC server address for direct queries
  last_heartbeat   TIMESTAMP,
  license_expires  TIMESTAMP,      -- License-to-sign expiration
  status           TEXT            -- "active" | "expired" | "revoked"
)
```

## DNS RRtypes

### KMCTRL (Key Management Control)

**RRtype**: TBD (experimental, e.g., 65XXX)

**Format**:
```
<zone>.kdc.example.com. IN KMCTRL <distribution-id> <keyid> <state> <timestamp>
```

**Fields**:
- `distribution-id`: Unique identifier for this key distribution (hex string)
- `keyid`: DNSSEC key ID (16-bit)
- `state`: "published" | "active" | "standby"
- `timestamp`: Unix timestamp of distribution

**Example**:
```
example.com.kdc.example.com. IN KMCTRL a1b2c3d4e5f6 12345 published 1704067200
```

### KMREQ (Key Management Request)

**RRtype**: TBD (experimental, e.g., 65XXX)

**Format** (in query):
```
<distribution-id>.<zone>.kdc.example.com. IN KMREQ <ephemeral-pubkey>
```

**QNAME encoding**:
- Format: `<distribution-id>.<zone>.kdc.example.com`
- Distribution ID: hex string (e.g., "a1b2c3d4e5f6")
- Zone: base64url-encoded zone name
- Ephemeral public key: in EDNS(0) option or encoded in QNAME

**EDNS(0) Option**: `EDNS0_HPKE_EPHEMERAL` (code TBD)
- Contains ephemeral HPKE public key (X25519 = 32 bytes)

**SIG(0)**: Query must be signed with edge's long-term SIG(0) key

### KMPKG (Key Management Package)

**RRtype**: TBD (experimental, e.g., 65XXX)

**Format** (in response):
```
<distribution-id>.<zone>.kdc.example.com. IN KMPKG <encrypted-key-data>
```

**Fields**:
- `encrypted-key-data`: HPKE-encrypted ZSK private key (base64-encoded)
- May be split across multiple KMPKG records if large

**Response Structure**:
- Answer section: One or more KMPKG RRs
- Authority section: SOA of control zone
- Additional section: RRSIG(KMPKG) for validation (future)

## DNS Protocol Flow

### 1. NOTIFY Phase
```
KDC → Edge: NOTIFY <control-zone>
```

### 2. Control Query Phase
```
Edge → KDC: Query KMCTRL records for control zone
KDC → Edge: KMCTRL RRs in Answer section
```

### 3. Key Request Phase
```
Edge → KDC: KMREQ query
  - QNAME: <distribution-id>.<zone>.kdc.example.com
  - QTYPE: KMREQ
  - EDNS(0): Ephemeral public key
  - SIG(0): Edge authentication
  - CD=1, RD=0 (no caching, no recursion)
  
KDC → Edge: KMPKG response
  - Answer: KMPKG RR(s) with encrypted keys
  - Authority: SOA
  - Rcode: NOERROR
```

### 4. Key Injection Phase
```
Edge: Decrypt KMPKG → Inject into KeyDB
```

## Security Considerations

1. **Forward Secrecy**: Ephemeral keys ensure past communications remain secure even if long-term keys are compromised
2. **Key Isolation**: Each edge node only receives keys it's authorized for
3. **Rapid Revocation**: Compromised edges can be immediately excluded
4. **License-to-Sign**: Future heartbeat mechanism ensures edges lose signing capability if disconnected from KDC
5. **In-Memory Storage**: Future enhancement to never store private keys on disk

## Implementation Phases

### Phase 1: Foundation
- HPKE library integration
- Basic data structures
- Database schema

### Phase 2: KDC Core
- Key generation
- HPKE encryption
- Basic distribution

### Phase 3: Edge Integration
- HPKE decryption
- Key injection into KeyDB
- EDNS(0) option handling

### Phase 4: Advanced Features
- Rapid rollover mechanism
- Heartbeat/license-to-sign
- In-memory keystore

## Implementation Details

### HPKE Library
- **Choice**: Cloudflare CIRCL (`github.com/cloudflare/circl/hpke`)
- **Configuration**:
  - Mode: Base (no sender authentication)
  - KEM: X25519
  - KDF: HKDF-SHA256
  - AEAD: AES-256-GCM

### Database Choice
- **KDC**: MariaDB (production-grade, better for multi-user scenarios)
- **Edge**: SQLite (existing KeyDB, single-user scenario)

### SIG(0) Integration
- Edge authenticates to KDC using SIG(0) on KMREQ queries
- KDC validates SIG(0) signature before processing request
- Uses existing SIG(0) infrastructure in tdns

### Direct Query Requirement
- KMREQ queries must go directly to KDC (no caching)
- Use CD=1 (Checking Disabled) to prevent resolver caching
- Use RD=0 (Recursion Desired = false)
- Edge must know KDC's IP address(es) for direct queries

## Open Questions

1. Should we use a separate `tdns-krs` (Key Receiving Service) or integrate into `tdns-auth`?
   - **Recommendation**: Integrate into `tdns-auth` initially, can extract later if needed

2. How to handle KDC high availability?
   - Multiple KDC instances with MariaDB replication?
   - DNS-based load balancing?

3. Key rotation policy for long-term HPKE keys?
   - Manual rotation initially
   - Automated rotation in future?

4. Audit logging requirements?
   - Log all key distributions
   - Log all KMREQ queries
   - Log key activations/revocations

5. RRtype assignments?
   - Need to request experimental RRtypes from IANA
   - Or use private RRtype space (65XXX range)

6. Control zone structure?
   - Single control zone per KDC?
   - Or per-zone subdomains?

