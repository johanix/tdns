
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>core: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/johanix/tdns/v0.x/tdns/core/concurrent_map.go (0.0%)</option>
				
				<option value="file1">github.com/johanix/tdns/v0.x/tdns/core/dnsclient.go (0.0%)</option>
				
				<option value="file2">github.com/johanix/tdns/v0.x/tdns/core/miek_utils.go (32.8%)</option>
				
				<option value="file3">github.com/johanix/tdns/v0.x/tdns/core/rr_chunk2.go (30.4%)</option>
				
				<option value="file4">github.com/johanix/tdns/v0.x/tdns/core/rr_defs.go (0.0%)</option>
				
				<option value="file5">github.com/johanix/tdns/v0.x/tdns/core/rr_deleg.go (7.1%)</option>
				
				<option value="file6">github.com/johanix/tdns/v0.x/tdns/core/rr_dsync.go (26.0%)</option>
				
				<option value="file7">github.com/johanix/tdns/v0.x/tdns/core/rr_hsync.go (26.8%)</option>
				
				<option value="file8">github.com/johanix/tdns/v0.x/tdns/core/rr_hsync2.go (47.7%)</option>
				
				<option value="file9">github.com/johanix/tdns/v0.x/tdns/core/rr_jsonchunk.go (27.6%)</option>
				
				<option value="file10">github.com/johanix/tdns/v0.x/tdns/core/rr_jsonmanifest.go (15.9%)</option>
				
				<option value="file11">github.com/johanix/tdns/v0.x/tdns/core/rr_msigner.go (26.7%)</option>
				
				<option value="file12">github.com/johanix/tdns/v0.x/tdns/core/rr_notify.go (26.8%)</option>
				
				<option value="file13">github.com/johanix/tdns/v0.x/tdns/core/rr_tsync.go (28.5%)</option>
				
				<option value="file14">github.com/johanix/tdns/v0.x/tdns/core/rrset_utils.go (0.0%)</option>
				
				<option value="file15">github.com/johanix/tdns/v0.x/tdns/core/transport.go (0.0%)</option>
				
				<option value="file16">github.com/johanix/tdns/v0.x/tdns/core/zscan.go (22.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
 * Slightly tweaked version of github.com/orcaman/concurrent-mapv2
 */

package core

import (
        "encoding/json"
        "fmt"
        "sync"
        // "github.com/gookit/goutil/dump"
)

const shardCount = 16

type Stringer interface {
        fmt.Stringer
        comparable
}

// A "thread" safe map of type string:Anything.
// To avoid lock bottlenecks this map is dived to several (shardCount) map shards.
type ConcurrentMap[K comparable, V any] struct {
        shards   []*ConcurrentMapShared[K, V]
        sharding func(key K) uint32
}

// A "thread" safe string to anything map.
type ConcurrentMapShared[K comparable, V any] struct {
        items        map[K]V
        sync.RWMutex // Read Write mutex, guards access to internal map.
}

func create[K comparable, V any](sharding func(key K) uint32) ConcurrentMap[K, V] <span class="cov0" title="0">{
        m := ConcurrentMap[K, V]{
                sharding: sharding,
                shards:   make([]*ConcurrentMapShared[K, V], shardCount),
        }
        for i := 0; i &lt; shardCount; i++ </span><span class="cov0" title="0">{
                m.shards[i] = &amp;ConcurrentMapShared[K, V]{items: make(map[K]V)}
        }</span>
        // log.Printf("ConcurrentMap:create: created concurrent map with %d shards", len(m.shards))
        <span class="cov0" title="0">return m</span>
}

// Creates a new concurrent map.
func NewCmap[V any]() *ConcurrentMap[string, V] <span class="cov0" title="0">{
        cm := create[string, V](fnv32)
        return &amp;cm
}</span>

// Creates a new concurrent map.
func NewStringer[K Stringer, V any]() ConcurrentMap[K, V] <span class="cov0" title="0">{
        return create[K, V](strfnv32[K])
}</span>

// Creates a new concurrent map.
func NewWithCustomShardingFunction[K comparable, V any](sharding func(key K) uint32) ConcurrentMap[K, V] <span class="cov0" title="0">{
        return create[K, V](sharding)
}</span>

// GetShard returns shard under given key
func (m *ConcurrentMap[K, V]) GetShard(key K) *ConcurrentMapShared[K, V] <span class="cov0" title="0">{
        return m.shards[uint(m.sharding(key))%uint(shardCount)]
}</span>

func (m *ConcurrentMap[K, V]) NumShards() int <span class="cov0" title="0">{
        return len(m.shards)
}</span>

func (m *ConcurrentMap[K, V]) MSet(data map[K]V) <span class="cov0" title="0">{
        for key, value := range data </span><span class="cov0" title="0">{
                shard := m.GetShard(key)
                shard.Lock()
                shard.items[key] = value
                shard.Unlock()
        }</span>
}

// Sets the given value under the specified key.
func (m *ConcurrentMap[K, V]) Set(key K, value V) <span class="cov0" title="0">{
        // Get map shard.
        shard := m.GetShard(key)
        shard.Lock()
        shard.items[key] = value
        shard.Unlock()
}</span>

// Callback to return new element to be inserted into the map
// It is called while lock is held, therefore it MUST NOT
// try to access other keys in same map, as it can lead to deadlock since
// Go sync.RWLock is not reentrant
type UpsertCb[V any] func(exist bool, valueInMap V, newValue V) V

// Insert or Update - updates existing element or inserts a new one using UpsertCb
func (m *ConcurrentMap[K, V]) Upsert(key K, value V, cb UpsertCb[V]) (res V) <span class="cov0" title="0">{
        shard := m.GetShard(key)
        shard.Lock()
        v, ok := shard.items[key]
        res = cb(ok, v, value)
        shard.items[key] = res
        shard.Unlock()
        return res
}</span>

// Sets the given value under the specified key if no value was associated with it.
func (m *ConcurrentMap[K, V]) SetIfAbsent(key K, value V) bool <span class="cov0" title="0">{
        // Get map shard.
        shard := m.GetShard(key)
        shard.Lock()
        _, ok := shard.items[key]
        if !ok </span><span class="cov0" title="0">{
                shard.items[key] = value
        }</span>
        <span class="cov0" title="0">shard.Unlock()
        return !ok</span>
}

// Get retrieves an element from map under given key.
func (m *ConcurrentMap[K, V]) Get(key K) (V, bool) <span class="cov0" title="0">{
        // Get shard
        shard := m.GetShard(key)
        shard.RLock()
        // Get item from shard.
        val, ok := shard.items[key]
        shard.RUnlock()
        return val, ok
}</span>

// Count returns the number of elements within the map.
func (m *ConcurrentMap[K, V]) Count() int <span class="cov0" title="0">{
        count := 0
        for i := 0; i &lt; shardCount; i++ </span><span class="cov0" title="0">{
                shard := m.shards[i]
                shard.RLock()
                count += len(shard.items)
                shard.RUnlock()
        }</span>
        <span class="cov0" title="0">return count</span>
}

// Looks up an item under specified key
func (m *ConcurrentMap[K, V]) Has(key K) bool <span class="cov0" title="0">{
        // Get shard
        shard := m.GetShard(key)
        shard.RLock()
        // See if element is within shard.
        _, ok := shard.items[key]
        shard.RUnlock()
        return ok
}</span>

// Remove removes an element from the map.
func (m *ConcurrentMap[K, V]) Remove(key K) <span class="cov0" title="0">{
        // Try to get shard.
        shard := m.GetShard(key)
        shard.Lock()
        delete(shard.items, key)
        shard.Unlock()
}</span>

// RemoveCb is a callback executed in a map.RemoveCb() call, while Lock is held
// If returns true, the element will be removed from the map
type RemoveCb[K any, V any] func(key K, v V, exists bool) bool

// RemoveCb locks the shard containing the key, retrieves its current value and calls the callback with those params
// If callback returns true and element exists, it will remove it from the map
// Returns the value returned by the callback (even if element was not present in the map)
func (m *ConcurrentMap[K, V]) RemoveCb(key K, cb RemoveCb[K, V]) bool <span class="cov0" title="0">{
        // Try to get shard.
        shard := m.GetShard(key)
        shard.Lock()
        v, ok := shard.items[key]
        remove := cb(key, v, ok)
        if remove &amp;&amp; ok </span><span class="cov0" title="0">{
                delete(shard.items, key)
        }</span>
        <span class="cov0" title="0">shard.Unlock()
        return remove</span>
}

// Pop removes an element from the map and returns it
func (m *ConcurrentMap[K, V]) Pop(key K) (v V, exists bool) <span class="cov0" title="0">{
        // Try to get shard.
        shard := m.GetShard(key)
        shard.Lock()
        v, exists = shard.items[key]
        delete(shard.items, key)
        shard.Unlock()
        return v, exists
}</span>

// IsEmpty checks if map is empty.
func (m *ConcurrentMap[K, V]) IsEmpty() bool <span class="cov0" title="0">{
        return m.Count() == 0
}</span>

// Used by the Iter &amp; IterBuffered functions to wrap two variables together over a channel,
type Tuple[K comparable, V any] struct {
        Key K
        Val V
}

// Iter returns an iterator which could be used in a for range loop.
//
// Deprecated: using IterBuffered() will get a better performence
func (m *ConcurrentMap[K, V]) Iter() &lt;-chan Tuple[K, V] <span class="cov0" title="0">{
        chans := snapshot(m)
        ch := make(chan Tuple[K, V])
        go fanIn(chans, ch)
        return ch
}</span>

// IterBuffered returns a buffered iterator which could be used in a for range loop.
func (m *ConcurrentMap[K, V]) IterBuffered() &lt;-chan Tuple[K, V] <span class="cov0" title="0">{
        // log.Printf("ConcurrentMap:IterBuffered: snapshotting %d shards", len(m.shards))
        chans := snapshot(m)
        total := 0
        for _, c := range chans </span><span class="cov0" title="0">{
                total += cap(c)
        }</span>
        <span class="cov0" title="0">ch := make(chan Tuple[K, V], total)
        go fanIn(chans, ch)
        return ch</span>
}

// Clear removes all items from map.
func (m *ConcurrentMap[K, V]) Clear() <span class="cov0" title="0">{
        // for item := range m.IterBuffered() {
        //         m.Remove(item.Key)
        // }
        for _, shard := range m.shards </span><span class="cov0" title="0">{
                shard.Lock()
                shard.items = make(map[K]V)
                shard.Unlock()
        }</span>
}

// Returns a array of channels that contains elements in each shard,
// which likely takes a snapshot of `m`.
// It returns once the size of each buffered channel is determined,
// before all the channels are populated using goroutines.
func snapshot[K comparable, V any](m *ConcurrentMap[K, V]) (chans []chan Tuple[K, V]) <span class="cov0" title="0">{
        //When you access map items before initializing.
        if len(m.shards) == 0 </span><span class="cov0" title="0">{
                // dump.P(m)
                panic(`cmap.ConcurrentMap is not initialized. Should run NewCmap() before usage.`)</span>
        }
        <span class="cov0" title="0">chans = make([]chan Tuple[K, V], shardCount)
        wg := sync.WaitGroup{}
        wg.Add(shardCount)
        // Foreach shard.
        for index, shard := range m.shards </span><span class="cov0" title="0">{
                go func(index int, shard *ConcurrentMapShared[K, V]) </span><span class="cov0" title="0">{
                        // Foreach key, value pair.
                        shard.RLock()
                        chans[index] = make(chan Tuple[K, V], len(shard.items))
                        wg.Done()
                        for key, val := range shard.items </span><span class="cov0" title="0">{
                                chans[index] &lt;- Tuple[K, V]{key, val}
                        }</span>
                        <span class="cov0" title="0">shard.RUnlock()
                        close(chans[index])</span>
                }(index, shard)
        }
        <span class="cov0" title="0">wg.Wait()
        return chans</span>
}

// fanIn reads elements from channels `chans` into channel `out`
func fanIn[K comparable, V any](chans []chan Tuple[K, V], out chan Tuple[K, V]) <span class="cov0" title="0">{
        wg := sync.WaitGroup{}
        wg.Add(len(chans))
        for _, ch := range chans </span><span class="cov0" title="0">{
                go func(ch chan Tuple[K, V]) </span><span class="cov0" title="0">{
                        for t := range ch </span><span class="cov0" title="0">{
                                out &lt;- t
                        }</span>
                        <span class="cov0" title="0">wg.Done()</span>
                }(ch)
        }
        <span class="cov0" title="0">wg.Wait()
        close(out)</span>
}

// Items returns all items as map[string]V
func (m *ConcurrentMap[K, V]) Items() map[K]V <span class="cov0" title="0">{
        tmp := make(map[K]V)

        // Insert items to temporary map.
        for item := range m.IterBuffered() </span><span class="cov0" title="0">{
                tmp[item.Key] = item.Val
        }</span>

        <span class="cov0" title="0">return tmp</span>
}

// Iterator callback called for every key,value found in
// maps. RLock is held for all calls for a given shard
// therefore callback sees a consistent view of a shard,
// but not across the shards
type IterCb[K comparable, V any] func(key K, v V)

// Callback based iterator, cheapest way to read
// all elements in a map.
func (m *ConcurrentMap[K, V]) IterCb(fn IterCb[K, V]) <span class="cov0" title="0">{
        for idx := range m.shards </span><span class="cov0" title="0">{
                shard := (m.shards)[idx]
                shard.RLock()
                for key, value := range shard.items </span><span class="cov0" title="0">{
                        fn(key, value)
                }</span>
                <span class="cov0" title="0">shard.RUnlock()</span>
        }
}

// Keys returns all keys as []string
func (m *ConcurrentMap[K, V]) Keys() []K <span class="cov0" title="0">{
        count := m.Count()
        ch := make(chan K, count)
        go func() </span><span class="cov0" title="0">{
                // Foreach shard.
                wg := sync.WaitGroup{}
                wg.Add(shardCount)
                for _, shard := range m.shards </span><span class="cov0" title="0">{
                        go func(shard *ConcurrentMapShared[K, V]) </span><span class="cov0" title="0">{
                                // Foreach key, value pair.
                                shard.RLock()
                                for key := range shard.items </span><span class="cov0" title="0">{
                                        ch &lt;- key
                                }</span>
                                <span class="cov0" title="0">shard.RUnlock()
                                wg.Done()</span>
                        }(shard)
                }
                <span class="cov0" title="0">wg.Wait()
                close(ch)</span>
        }()

        // Generate keys
        <span class="cov0" title="0">keys := make([]K, 0, count)
        for k := range ch </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// Reviles ConcurrentMap "private" variables to json marshal.
func (m *ConcurrentMap[K, V]) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        // Create a temporary map, which will hold all item spread across shards.
        tmp := make(map[K]V)

        // Insert items to temporary map.
        for item := range m.IterBuffered() </span><span class="cov0" title="0">{
                tmp[item.Key] = item.Val
        }</span>
        <span class="cov0" title="0">return json.Marshal(tmp)</span>
}
func strfnv32[K fmt.Stringer](key K) uint32 <span class="cov0" title="0">{
        return fnv32(key.String())
}</span>

func fnv32(key string) uint32 <span class="cov0" title="0">{
        hash := uint32(2166136261)
        const prime32 = uint32(16777619)
        keyLength := len(key)
        for i := 0; i &lt; keyLength; i++ </span><span class="cov0" title="0">{
                hash *= prime32
                hash ^= uint32(key[i])
        }</span>
        <span class="cov0" title="0">return hash</span>
}

// Reverse process of Marshal.
func (m *ConcurrentMap[K, V]) UnmarshalJSON(b []byte) (err error) <span class="cov0" title="0">{
        tmp := make(map[K]V)

        // Unmarshal into a single map.
        if err := json.Unmarshal(b, &amp;tmp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // foreach key,value pair in temporary map insert into our concurrent map.
        <span class="cov0" title="0">for key, val := range tmp </span><span class="cov0" title="0">{
                m.Set(key, val)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
 * Copyright (c) 2024, 2025 Johan Stenstam, johan.stenstam@internetstiftelsen.se
 */

package core

import (
        "bytes"
        "context"
        "crypto/tls"
        "encoding/binary"
        "fmt"
        "io"
        "log"
        "net"
        "net/http"
        "time"

        "github.com/miekg/dns"
        "github.com/quic-go/quic-go"
)

// Transport represents the DNS transport protocol
type Transport uint8

const (
        TransportDo53 Transport = iota + 1
        TransportDoT
        TransportDoH
        TransportDoQ
)

var TransportToString = map[Transport]string{
        TransportDo53: "do53",
        TransportDoT:  "dot",
        TransportDoH:  "doh",
        TransportDoQ:  "doq",
}

// StringToTransport converts a string transport name to Transport type
func StringToTransport(s string) (Transport, error) <span class="cov0" title="0">{
        switch s </span>{
        case "do53", "Do53", "Do53-TCP":<span class="cov0" title="0">
                return TransportDo53, nil</span>
        case "tcp", "TCP":<span class="cov0" title="0">
                return TransportDo53, nil</span> // TCP is still Do53, just forced TCP
        case "dot", "DoT", "DoT-TCP":<span class="cov0" title="0">
                return TransportDoT, nil</span>
        case "doh", "DoH", "DoH-TCP":<span class="cov0" title="0">
                return TransportDoH, nil</span>
        case "doq", "DoQ", "DoQ-TCP":<span class="cov0" title="0">
                return TransportDoQ, nil</span>
        default:<span class="cov0" title="0">
                return TransportDo53, fmt.Errorf("unknown transport: %s", s)</span>
        }
}

// DNSClient represents a DNS client that supports multiple transport protocols
type DNSClient struct {
        Port            string
        Transport       Transport
        TLSConfig       *tls.Config
        HTTPClient      *http.Client
        QUICConfig      *quic.Config
        Timeout         time.Duration
        DNSClientUDP    *dns.Client
        DNSClientTCP    *dns.Client
        DNSClientTLS    *dns.Client
        DisableFallback bool
        ForceTCP        bool
}

type DNSClientOption func(*DNSClient)

func WithDisableFallback() DNSClientOption <span class="cov0" title="0">{
        return func(c *DNSClient) </span><span class="cov0" title="0">{
                c.DisableFallback = true
        }</span>
}

func WithForceTCP() DNSClientOption <span class="cov0" title="0">{
        return func(c *DNSClient) </span><span class="cov0" title="0">{
                c.ForceTCP = true
        }</span>
}

// NewDNSClient creates a new DNS client with the specified transport
// XXX: Once we can do cert validation we should add a WithVerifyCertificates() option.
func NewDNSClient(transport Transport, port string, tlsConfig *tls.Config, opts ...DNSClientOption) *DNSClient <span class="cov0" title="0">{
        if tlsConfig == nil </span><span class="cov0" title="0">{
                switch transport </span>{
                case TransportDoT, TransportDoH:<span class="cov0" title="0">
                        tlsConfig = &amp;tls.Config{
                                InsecureSkipVerify: true,
                                MinVersion:         tls.VersionTLS12,
                        }</span>
                case TransportDoQ:<span class="cov0" title="0">
                        tlsConfig = &amp;tls.Config{
                                InsecureSkipVerify: true,
                                NextProtos:         []string{"doq"},
                                MinVersion:         tls.VersionTLS12,
                        }</span>
                default:<span class="cov0" title="0">
                        tlsConfig = &amp;tls.Config{
                                MinVersion: tls.VersionTLS12,
                        }</span>
                }
        }

        <span class="cov0" title="0">client := &amp;DNSClient{
                Transport: transport,
                Port:      port,
                TLSConfig: tlsConfig,
                Timeout:   5 * time.Second,
        }

        // Initialize transport-specific configurations
        switch transport </span>{
        case TransportDo53:<span class="cov0" title="0">
                client.DNSClientUDP = &amp;dns.Client{Net: "udp", Timeout: client.Timeout}
                client.DNSClientTCP = &amp;dns.Client{Net: "tcp", Timeout: client.Timeout}</span>
        case TransportDoT:<span class="cov0" title="0">
                client.DNSClientTLS = &amp;dns.Client{
                        Net:       "tcp-tls",
                        TLSConfig: tlsConfig,
                        Timeout:   client.Timeout,
                }</span>
        case TransportDoH:<span class="cov0" title="0">
                client.HTTPClient = &amp;http.Client{
                        Transport: &amp;http.Transport{
                                TLSClientConfig: tlsConfig,
                        },
                        Timeout: client.Timeout,
                }</span>
        case TransportDoQ:<span class="cov0" title="0">
                // Ensure TLS 1.3 for DoQ per RFC 9250
                if client.TLSConfig != nil &amp;&amp; client.TLSConfig.MinVersion &lt; tls.VersionTLS13 </span><span class="cov0" title="0">{
                        client.TLSConfig.MinVersion = tls.VersionTLS13
                }</span>
                <span class="cov0" title="0">client.QUICConfig = &amp;quic.Config{
                        MaxIdleTimeout:  client.Timeout,
                        KeepAlivePeriod: client.Timeout / 2,
                }</span>
        }

        <span class="cov0" title="0">for _, opt := range opts </span><span class="cov0" title="0">{
                opt(client)
        }</span>

        <span class="cov0" title="0">return client</span>
}

// Exchange sends a DNS message and returns the response
func (c *DNSClient) Exchange(msg *dns.Msg, server string, debug bool) (*dns.Msg, time.Duration, error) <span class="cov0" title="0">{
        //        if !Globals.Debug {
        //                fmt.Printf("*** Exchange: Globals.Debug is NOT set\n")
        //        } else {
        //                fmt.Printf("*** Exchange: Globals.Debug is set\n")
        //        }
        if debug </span><span class="cov0" title="0">{
                fmt.Printf("*** Exchange: sending %s message to %s:%s opcode: %s qname: %s rrtype: %s\n",
                        TransportToString[c.Transport], server, c.Port,
                        dns.OpcodeToString[msg.Opcode],
                        msg.Question[0].Name, dns.TypeToString[msg.Question[0].Qtype])
        }</span>

        <span class="cov0" title="0">switch c.Transport </span>{
        case TransportDo53:<span class="cov0" title="0">
                if debug </span><span class="cov0" title="0">{
                        log.Printf("*** Do53 sending message to %s:%s opcode: %s qname: %s rrtype: %s",
                                server, c.Port,
                                dns.OpcodeToString[msg.Opcode],
                                msg.Question[0].Name, dns.TypeToString[msg.Question[0].Qtype])
                }</span>
                <span class="cov0" title="0">addr := net.JoinHostPort(server, c.Port)
                if c.ForceTCP </span><span class="cov0" title="0">{
                        return c.DNSClientTCP.Exchange(msg, addr)
                }</span>
                <span class="cov0" title="0">r, rtt, err := c.DNSClientUDP.Exchange(msg, addr)
                if err == nil &amp;&amp; r != nil &amp;&amp; r.Truncated &amp;&amp; !c.DisableFallback </span><span class="cov0" title="0">{
                        log.Printf("Do53: UDP response from %s truncated (TC=1); retrying over TCP", addr)
                        return c.DNSClientTCP.Exchange(msg, addr)
                }</span>
                <span class="cov0" title="0">return r, rtt, err</span>
        case TransportDoT:<span class="cov0" title="0">
                return c.DNSClientTLS.Exchange(msg, net.JoinHostPort(server, c.Port))</span>
        case TransportDoH:<span class="cov0" title="0">
                return c.exchangeDoH(msg, server, debug)</span>
        case TransportDoQ:<span class="cov0" title="0">
                return c.exchangeDoQ(msg, net.JoinHostPort(server, c.Port), debug)</span>
        default:<span class="cov0" title="0">
                return nil, 0, fmt.Errorf("unsupported transport protocol: %d", c.Transport)</span>
        }
}

// exchangeDoT handles DNS over TLS
// func (c *DNSClientNG) exchangeDoT(msg *dns.Msg, server string) (*dns.Msg, time.Duration, error) {
//        if Globals.Debug {
//                fmt.Printf("*** DoT sending message to %s opcode: %s qname: %s rrtype: %s\n", server, dns.OpcodeToString[msg.Opcode], msg.Question[0].Name, dns.TypeToString[msg.Question[0].Qtype])
//        }
//        return c.DNSClient.Exchange(msg, net.JoinHostPort(server, "853"))
// }

// exchangeDoH handles DNS over HTTPS
func (c *DNSClient) exchangeDoH(msg *dns.Msg, server string, debug bool) (*dns.Msg, time.Duration, error) <span class="cov0" title="0">{
        packed, err := msg.Pack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to pack DNS message: %v", err)
        }</span>

        // Determine port (default to 443 for HTTPS if not specified)
        <span class="cov0" title="0">port := c.Port
        if port == "" </span><span class="cov0" title="0">{
                port = "443"
        }</span>

        // Use net.JoinHostPort to properly handle IPv6 addresses (adds brackets if needed)
        // This returns format like "[::1]:8443" which is correct for URLs
        <span class="cov0" title="0">hostPort := net.JoinHostPort(server, port)

        // Create HTTP request
        url := fmt.Sprintf("https://%s/dns-query", hostPort)
        if debug </span><span class="cov0" title="0">{
                fmt.Printf("*** DoH sending HTTPS POST to %s opcode: %s qname: %s rrtype: %s\n", url, dns.OpcodeToString[msg.Opcode], msg.Question[0].Name, dns.TypeToString[msg.Question[0].Qtype])
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(packed))
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to create HTTP request: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/dns-message")
        req.Header.Set("Accept", "application/dns-message")

        // Send request
        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("HTTP request failed: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("HTTP request failed with status: %s", resp.Status)
        }</span>

        // Read response
        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to read HTTP response: %v", err)
        }</span>

        // Unpack DNS message
        <span class="cov0" title="0">response := new(dns.Msg)
        if err := response.Unpack(body); err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to unpack DNS response: %v", err)
        }</span>

        <span class="cov0" title="0">return response, 0, nil</span>
}

// exchangeDoQ handles DNS over QUIC
func (c *DNSClient) exchangeDoQ(msg *dns.Msg, server string, debug bool) (*dns.Msg, time.Duration, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), c.Timeout)
        defer cancel()

        if debug </span><span class="cov0" title="0">{
                fmt.Printf("*** DoQ sending message to %s opcode: %s qname: %s rrtype: %s\n", server, dns.OpcodeToString[msg.Opcode], msg.Question[0].Name, dns.TypeToString[msg.Question[0].Qtype])
        }</span>

        // Connect to the QUIC server
        <span class="cov0" title="0">conn, err := quic.DialAddr(ctx, server, c.TLSConfig, c.QUICConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("*** DoQ failed to connect to QUIC server: %v", err)
                return nil, 0, fmt.Errorf("failed to connect to QUIC server: %v", err)
        }</span>
        <span class="cov0" title="0">defer conn.CloseWithError(0, "")

        // Open a new stream
        stream, err := conn.OpenStreamSync(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("*** DoQ failed to open QUIC stream: %v", err)
                return nil, 0, fmt.Errorf("failed to open QUIC stream: %v", err)
        }</span>
        <span class="cov0" title="0">defer stream.Close()

        // Pack the DNS message
        packed, err := msg.Pack()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("*** DoQ failed to pack DNS message: %v", err)
                return nil, 0, fmt.Errorf("failed to pack DNS message: %v", err)
        }</span>

        // Write the length prefix (2 bytes) and the message
        <span class="cov0" title="0">lenBuf := make([]byte, 2)
        binary.BigEndian.PutUint16(lenBuf, uint16(len(packed)))
        if _, err := stream.Write(lenBuf); err != nil </span><span class="cov0" title="0">{
                log.Printf("*** DoQ failed to write message length: %v", err)
                return nil, 0, fmt.Errorf("failed to write message length: %v", err)
        }</span>
        <span class="cov0" title="0">if _, err := stream.Write(packed); err != nil </span><span class="cov0" title="0">{
                log.Printf("*** DoQ failed to write DNS message: %v", err)
                return nil, 0, fmt.Errorf("failed to write DNS message: %v", err)
        }</span>

        // Read the response length
        <span class="cov0" title="0">if _, err := io.ReadFull(stream, lenBuf); err != nil </span><span class="cov0" title="0">{
                log.Printf("*** DoQ failed to read response length: %v", err)
                return nil, 0, fmt.Errorf("failed to read response length: %v", err)
        }</span>
        <span class="cov0" title="0">respLen := binary.BigEndian.Uint16(lenBuf)

        // Read the response
        respBuf := make([]byte, respLen)
        if _, err := io.ReadFull(stream, respBuf); err != nil </span><span class="cov0" title="0">{
                log.Printf("*** DoQ failed to read response: %v", err)
                return nil, 0, fmt.Errorf("failed to read response: %v", err)
        }</span>

        <span class="cov0" title="0">if debug </span><span class="cov0" title="0">{
                fmt.Printf("*** DoQ received response length: %d. Now closing stream\n", respLen)
        }</span>

        // Unpack the response
        <span class="cov0" title="0">response := new(dns.Msg)
        if err := response.Unpack(respBuf); err != nil </span><span class="cov0" title="0">{
                log.Printf("*** DoQ failed to unpack response: %v", err)
                // stream.Close()
                return nil, 0, fmt.Errorf("failed to unpack response: %v", err)
        }</span>

        // Properly close the stream after we're done with it
        <span class="cov0" title="0">stream.CancelRead(0)
        // stream.Close()

        return response, 0, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
 * Stolen from Mieks DNS lib
 */

package core

import (
        "encoding/base64"
        "strings"
)

// cloneSlice returns a shallow copy of s.
func cloneSlice[E any, S ~[]E](s S) S <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return append(S(nil), s...)</span>
}

func nextByte(s string, offset int) (byte, int) <span class="cov8" title="1">{
        if offset &gt;= len(s) </span><span class="cov0" title="0">{
                return 0, 0
        }</span>
        <span class="cov8" title="1">if s[offset] != '\\' </span><span class="cov8" title="1">{
                // not an escape sequence
                return s[offset], 1
        }</span>
        <span class="cov0" title="0">switch len(s) - offset </span>{
        case 1:<span class="cov0" title="0"> // dangling escape
                return 0, 0</span>
        case 2, 3:<span class="cov0" title="0"></span> // too short to be \ddd
        default:<span class="cov0" title="0"> // maybe \ddd
                if isDDD(s[offset+1:]) </span><span class="cov0" title="0">{
                        return dddToByte(s[offset+1:]), 4
                }</span>
        }
        // not \ddd, just an RFC 1035 "quoted" character
        <span class="cov0" title="0">return s[offset+1], 2</span>
}

// escapeByte returns the \DDD escaping of b which must
// satisfy b &lt; ' ' || b &gt; '~'.
func escapeByte(b byte) string <span class="cov0" title="0">{
        if b &lt; ' ' </span><span class="cov0" title="0">{
                return escapedByteSmall[b*4 : b*4+4]
        }</span>

        <span class="cov0" title="0">b -= '~' + 1
        // The cast here is needed as b*4 may overflow byte.
        return escapedByteLarge[int(b)*4 : int(b)*4+4]</span>
}

const (
        escapedByteSmall = "" +
                `\000\001\002\003\004\005\006\007\008\009` +
                `\010\011\012\013\014\015\016\017\018\019` +
                `\020\021\022\023\024\025\026\027\028\029` +
                `\030\031`
        escapedByteLarge = `\127\128\129` +
                `\130\131\132\133\134\135\136\137\138\139` +
                `\140\141\142\143\144\145\146\147\148\149` +
                `\150\151\152\153\154\155\156\157\158\159` +
                `\160\161\162\163\164\165\166\167\168\169` +
                `\170\171\172\173\174\175\176\177\178\179` +
                `\180\181\182\183\184\185\186\187\188\189` +
                `\190\191\192\193\194\195\196\197\198\199` +
                `\200\201\202\203\204\205\206\207\208\209` +
                `\210\211\212\213\214\215\216\217\218\219` +
                `\220\221\222\223\224\225\226\227\228\229` +
                `\230\231\232\233\234\235\236\237\238\239` +
                `\240\241\242\243\244\245\246\247\248\249` +
                `\250\251\252\253\254\255`
)

func sprintName(s string) string <span class="cov8" title="1">{
        var dst strings.Builder

        for i := 0; i &lt; len(s); </span><span class="cov8" title="1">{
                if s[i] == '.' </span><span class="cov8" title="1">{
                        if dst.Len() != 0 </span><span class="cov0" title="0">{
                                dst.WriteByte('.')
                        }</span>
                        <span class="cov8" title="1">i++
                        continue</span>
                }

                <span class="cov8" title="1">b, n := nextByte(s, i)
                if n == 0 </span><span class="cov0" title="0">{
                        // Drop "dangling" incomplete escapes.
                        if dst.Len() == 0 </span><span class="cov0" title="0">{
                                return s[:i]
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov8" title="1">if isDomainNameLabelSpecial(b) </span><span class="cov0" title="0">{
                        if dst.Len() == 0 </span><span class="cov0" title="0">{
                                dst.Grow(len(s) * 2)
                                dst.WriteString(s[:i])
                        }</span>
                        <span class="cov0" title="0">dst.WriteByte('\\')
                        dst.WriteByte(b)</span>
                } else<span class="cov8" title="1"> if b &lt; ' ' || b &gt; '~' </span><span class="cov0" title="0">{ // unprintable, use \DDD
                        if dst.Len() == 0 </span><span class="cov0" title="0">{
                                dst.Grow(len(s) * 2)
                                dst.WriteString(s[:i])
                        }</span>
                        <span class="cov0" title="0">dst.WriteString(escapeByte(b))</span>
                } else<span class="cov8" title="1"> {
                        if dst.Len() != 0 </span><span class="cov0" title="0">{
                                dst.WriteByte(b)
                        }</span>
                }
                <span class="cov8" title="1">i += n</span>
        }
        <span class="cov8" title="1">if dst.Len() == 0 </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov0" title="0">return dst.String()</span>
}

// Helpers for dealing with escaped bytes
func isDigit(b byte) bool <span class="cov0" title="0">{ return b &gt;= '0' &amp;&amp; b &lt;= '9' }</span>

func isDDD[T ~[]byte | ~string](s T) bool <span class="cov0" title="0">{
        return len(s) &gt;= 3 &amp;&amp; isDigit(s[0]) &amp;&amp; isDigit(s[1]) &amp;&amp; isDigit(s[2])
}</span>

func dddToByte[T ~[]byte | ~string](s T) byte <span class="cov0" title="0">{
        _ = s[2] // bounds check hint to compiler; see golang.org/issue/14808
        return byte((s[0]-'0')*100 + (s[1]-'0')*10 + (s[2] - '0'))
}</span>

// Helper function for packing and unpacking
// func intToBytes(i *big.Int, length int) []byte {
//         buf := i.Bytes()
//         if len(buf) &lt; length {
//                 b := make([]byte, length)
//                 copy(b[length-len(buf):], buf)
//                 return b
//         }
//         return buf
// }

func fromBase64(s []byte) (buf []byte, err error) <span class="cov0" title="0">{
        buflen := base64.StdEncoding.DecodedLen(len(s))
        buf = make([]byte, buflen)
        n, err := base64.StdEncoding.Decode(buf, s)
        buf = buf[:n]
        return
}</span>

func toBase64(b []byte) string <span class="cov0" title="0">{ return base64.StdEncoding.EncodeToString(b) }</span>

// isDomainNameLabelSpecial returns true if
// a domain name label byte should be prefixed
// with an escaping backslash.
func isDomainNameLabelSpecial(b byte) bool <span class="cov8" title="1">{
        switch b </span>{
        case '.', ' ', '\'', '@', ';', '(', ')', '"', '\\':<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
 * Copyright (c) 2025 Johan Stenstam, johani@johani.org
 */

package core

import (
        "encoding/base64"
        "encoding/binary"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "strconv"
        "strings"

        "github.com/miekg/dns"
)

func init() <span class="cov8" title="1">{
        RegisterCHUNK2RR()
}</span>

// CHUNK2 - Unified Chunk/Manifest RR type
// Combines MANIFEST and CHUNK functionality into a single RR type
// Fixed RDATA structure with all fields always present (some unused depending on context)
//
// RDATA structure (fixed field order):
//   - Format (uint8): Format identifier (used when Total=0, stored from manifest when Total&gt;0)
//   - HMAC length (uint16): Length of HMAC (0 for data chunks, &gt;0 for manifest)
//   - HMAC ([]byte): HMAC-SHA256 checksum (only present if HMAC length &gt; 0)
//   - Sequence (uint16): Chunk sequence number (unused when Total=0, used when Total&gt;0)
//   - Total (uint16): Total chunks or 0 for manifest (0 = manifest, &gt;0 = data chunk)
//   - Data length (uint16): Length of data
//   - Data ([]byte): Format-specific data (JSON manifest or chunk payload)
//
// Semantics:
//   - When Total=0: This is a manifest chunk
//     * Format: Set (e.g., FormatJSON=1)
//     * HMAC length: &gt;0 (typically 32 for SHA-256)
//     * HMAC: Present (length from HMAC length field)
//     * Sequence: Unused (can be 0)
//     * Total: 0 (indicates manifest)
//     * Data: JSON manifest data (ChunkCount, ChunkSize, Metadata, Payload)
//
//   - When Total&gt;0: This is a data chunk
//     * Format: Stored from manifest (e.g., FormatJSON=1)
//     * HMAC length: 0
//     * HMAC: Not present (HMACLen=0)
//     * Sequence: Chunk sequence number (0-based)
//     * Total: Total number of chunks
//     * Data: Chunk payload data
//
// Presentation format (space-separated values):
//   - Manifest chunk: &lt;sequence&gt; &lt;total&gt; &lt;format&gt; &lt;hmac&gt; &lt;json-data&gt;
//     Example:
//     node.distid.control. IN CHUNK2 0 0 JSON a889a20e0722d903fe0772226ddd21bce465056f94785ea3dbba74069c897092
//                                    {"chunk_count":1,"chunk_size":60000,"metadata":{"content":"encrypted_keys","distribution_id":"3a29c33a"},"payload":"&lt;base64-encoded-payload&gt;"}"
//   - Data chunk: &lt;sequence&gt; &lt;total&gt; &lt;format&gt; &lt;hmac&gt; &lt;base64-data&gt;
//     Example:
//     node.distid.control. IN CHUNK2 1 2 JSON "" bWhBdGRTlac0hX2p0eGZzSW9kcHJKZ2d...QY1c3b05uYTd3aWpORXlLUDMrWG10T3c9PQ==

type CHUNK2 struct {
        Format     uint8  // Format identifier (used for manifest, unused for data chunks)
        HMACLen    uint16 // HMAC length (0 for data chunks, &gt;0 for manifest)
        HMAC       []byte // HMAC-SHA256 checksum (only present if HMACLen &gt; 0)
        Sequence   uint16 // Chunk sequence number (unused when Total=0)
        Total      uint16 // Total chunks or 0 for manifest (0 = manifest, &gt;0 = data chunk)
        DataLength uint16 // Length of data
        Data       []byte // Format-specific data (JSON manifest or chunk payload)
}

func NewCHUNK2() dns.PrivateRdata <span class="cov0" title="0">{ return new(CHUNK2) }</span>

func (rd CHUNK2) String() string <span class="cov8" title="1">{
        // Format field (always present)
        formatStr := FormatToString[rd.Format]
        if formatStr == "" </span><span class="cov0" title="0">{
                formatStr = fmt.Sprintf("FORMAT%d", rd.Format)
        }</span>
        
        // HMAC field (always present)
        <span class="cov8" title="1">var hmacStr string
        if rd.HMACLen &gt; 0 &amp;&amp; rd.HMAC != nil </span><span class="cov8" title="1">{
                hmacStr = fmt.Sprintf("%x", rd.HMAC)
        }</span> else<span class="cov8" title="1"> {
                hmacStr = `""` // Empty string for data chunks
        }</span>
        
        // Data field: try to parse as JSON for manifest chunks, otherwise base64
        <span class="cov8" title="1">var dataStr string
        if rd.Total == 0 </span><span class="cov8" title="1">{
                // Manifest chunk: try to parse JSON for better display
                var manifestData struct {
                        ChunkCount uint16                 `json:"chunk_count"`
                        ChunkSize  uint16                 `json:"chunk_size,omitempty"`
                        Metadata   map[string]interface{} `json:"metadata,omitempty"`
                        Payload    []byte                 `json:"payload,omitempty"`
                }
                if err := json.Unmarshal(rd.Data, &amp;manifestData); err == nil </span><span class="cov8" title="1">{
                        jsonBytes, _ := json.Marshal(manifestData)
                        dataStr = string(jsonBytes)
                }</span> else<span class="cov0" title="0"> {
                        // Fallback if JSON parsing fails
                        dataStr = base64.StdEncoding.EncodeToString(rd.Data)
                }</span>
        } else<span class="cov8" title="1"> {
                // Data chunk: base64 encode
                dataStr = base64.StdEncoding.EncodeToString(rd.Data)
        }</span>
        
        // Order: Sequence Total Format HMAC Data
        <span class="cov8" title="1">return fmt.Sprintf("%d %d %s %s %s", rd.Sequence, rd.Total, formatStr, hmacStr, dataStr)</span>
}

func (rd *CHUNK2) Parse(txt []string) error <span class="cov8" title="1">{
        // CHUNK2 String() format: "Sequence Total Format HMAC Data"
        // Format: "JSON" or "FORMAT&lt;n&gt;"
        // HMAC: hex string or "" for data chunks
        // Data: JSON (for manifest) or base64 (for data chunks)
        
        if len(txt) &lt; 5 </span><span class="cov0" title="0">{
                return errors.New("CHUNK2 requires 5 fields: Sequence Total Format HMAC Data")
        }</span>

        // Parse Sequence (uint16)
        <span class="cov8" title="1">seq, err := strconv.ParseUint(txt[0], 10, 16)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid CHUNK2 sequence: %s", txt[0])
        }</span>
        <span class="cov8" title="1">rd.Sequence = uint16(seq)

        // Parse Total (uint16)
        total, err := strconv.ParseUint(txt[1], 10, 16)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid CHUNK2 total: %s", txt[1])
        }</span>
        <span class="cov8" title="1">rd.Total = uint16(total)

        // Parse Format (string -&gt; enum)
        formatStr := txt[2]
        if format, ok := StringToFormat[formatStr]; ok </span><span class="cov8" title="1">{
                rd.Format = format
        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(formatStr, "FORMAT") </span><span class="cov0" title="0">{
                // Format like "FORMAT1" (fallback for unknown formats)
                formatNum, err := strconv.ParseUint(strings.TrimPrefix(formatStr, "FORMAT"), 10, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid CHUNK2 format: %s", formatStr)
                }</span>
                <span class="cov0" title="0">rd.Format = uint8(formatNum)</span>
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("invalid CHUNK2 format: %s", formatStr)
        }</span>

        // Parse HMAC (hex string or "")
        <span class="cov8" title="1">hmacStr := txt[3]
        if hmacStr == `""` || hmacStr == "" </span><span class="cov8" title="1">{
                rd.HMACLen = 0
                rd.HMAC = nil
        }</span> else<span class="cov8" title="1"> {
                hmac, err := hex.DecodeString(hmacStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid CHUNK2 HMAC (hex): %s", hmacStr)
                }</span>
                <span class="cov8" title="1">rd.HMACLen = uint16(len(hmac))
                rd.HMAC = hmac</span>
        }

        // Parse Data (JSON for manifest, base64 for data chunk)
        <span class="cov8" title="1">dataStr := txt[4]
        if rd.Total == 0 </span><span class="cov8" title="1">{
                // Manifest: data is JSON
                rd.Data = []byte(dataStr)
                rd.DataLength = uint16(len(rd.Data))
        }</span> else<span class="cov8" title="1"> {
                // Data chunk: data is base64
                data, err := base64.StdEncoding.DecodeString(dataStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid CHUNK2 base64 data: %v", err)
                }</span>
                <span class="cov8" title="1">rd.Data = data
                rd.DataLength = uint16(len(data))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (rd *CHUNK2) Pack(buf []byte) (int, error) <span class="cov0" title="0">{
        off := 0

        // Pack Format (uint8)
        if len(buf) &lt; off+1 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too small for CHUNK2 format")
        }</span>
        <span class="cov0" title="0">buf[off] = rd.Format
        off += 1

        // Pack HMAC length (uint16)
        if len(buf) &lt; off+2 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too small for CHUNK2 HMAC length")
        }</span>
        <span class="cov0" title="0">buf[off] = byte(rd.HMACLen &gt;&gt; 8)
        buf[off+1] = byte(rd.HMACLen)
        off += 2

        // Pack HMAC (only if HMACLen &gt; 0)
        if rd.HMACLen &gt; 0 </span><span class="cov0" title="0">{
                if len(buf) &lt; off+int(rd.HMACLen) </span><span class="cov0" title="0">{
                        return off, errors.New("buffer too small for CHUNK2 HMAC")
                }</span>
                <span class="cov0" title="0">if len(rd.HMAC) != int(rd.HMACLen) </span><span class="cov0" title="0">{
                        return off, fmt.Errorf("CHUNK2 HMAC length mismatch: expected %d, got %d", rd.HMACLen, len(rd.HMAC))
                }</span>
                <span class="cov0" title="0">copy(buf[off:], rd.HMAC)
                off += int(rd.HMACLen)</span>
        }

        // Pack Sequence (uint16)
        <span class="cov0" title="0">if len(buf) &lt; off+2 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too small for CHUNK2 sequence")
        }</span>
        <span class="cov0" title="0">buf[off] = byte(rd.Sequence &gt;&gt; 8)
        buf[off+1] = byte(rd.Sequence)
        off += 2

        // Pack Total (uint16)
        if len(buf) &lt; off+2 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too small for CHUNK2 total")
        }</span>
        <span class="cov0" title="0">buf[off] = byte(rd.Total &gt;&gt; 8)
        buf[off+1] = byte(rd.Total)
        off += 2

        // Pack Data length (uint16)
        if len(buf) &lt; off+2 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too small for CHUNK2 data length")
        }</span>
        <span class="cov0" title="0">dataLen := len(rd.Data)
        if dataLen &gt; 65535 </span><span class="cov0" title="0">{
                return off, errors.New("CHUNK2 data too long")
        }</span>
        <span class="cov0" title="0">buf[off] = byte(dataLen &gt;&gt; 8)
        buf[off+1] = byte(dataLen)
        off += 2

        // Pack Data
        if len(buf) &lt; off+dataLen </span><span class="cov0" title="0">{
                return off, errors.New("buffer too small for CHUNK2 data")
        }</span>
        <span class="cov0" title="0">copy(buf[off:], rd.Data)
        off += dataLen

        return off, nil</span>
}

func (rd *CHUNK2) Unpack(buf []byte) (int, error) <span class="cov0" title="0">{
        off := 0

        // Unpack Format (uint8)
        if len(buf) &lt; off+1 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too short for CHUNK2 format")
        }</span>
        <span class="cov0" title="0">rd.Format = buf[off]
        off += 1

        // Unpack HMAC length (uint16)
        if len(buf) &lt; off+2 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too short for CHUNK2 HMAC length")
        }</span>
        <span class="cov0" title="0">rd.HMACLen = binary.BigEndian.Uint16(buf[off:])
        off += 2

        // Unpack HMAC (only if HMACLen &gt; 0)
        if rd.HMACLen &gt; 0 </span><span class="cov0" title="0">{
                if len(buf) &lt; off+int(rd.HMACLen) </span><span class="cov0" title="0">{
                        return off, errors.New("buffer too short for CHUNK2 HMAC")
                }</span>
                <span class="cov0" title="0">rd.HMAC = make([]byte, rd.HMACLen)
                copy(rd.HMAC, buf[off:off+int(rd.HMACLen)])
                off += int(rd.HMACLen)</span>
        } else<span class="cov0" title="0"> {
                rd.HMAC = nil
        }</span>

        // Unpack Sequence (uint16)
        <span class="cov0" title="0">if len(buf) &lt; off+2 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too short for CHUNK2 sequence")
        }</span>
        <span class="cov0" title="0">rd.Sequence = binary.BigEndian.Uint16(buf[off:])
        off += 2

        // Unpack Total (uint16)
        if len(buf) &lt; off+2 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too short for CHUNK2 total")
        }</span>
        <span class="cov0" title="0">rd.Total = binary.BigEndian.Uint16(buf[off:])
        off += 2

        // Unpack Data length (uint16)
        if len(buf) &lt; off+2 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too short for CHUNK2 data length")
        }</span>
        <span class="cov0" title="0">rd.DataLength = binary.BigEndian.Uint16(buf[off:])
        off += 2

        // Unpack Data
        if len(buf) &lt; off+int(rd.DataLength) </span><span class="cov0" title="0">{
                return off, errors.New("buffer too short for CHUNK2 data")
        }</span>
        <span class="cov0" title="0">rd.Data = make([]byte, rd.DataLength)
        copy(rd.Data, buf[off:off+int(rd.DataLength)])
        off += int(rd.DataLength)

        return off, nil</span>
}

func (rd *CHUNK2) Copy(dest dns.PrivateRdata) error <span class="cov0" title="0">{
        d := dest.(*CHUNK2)
        d.Format = rd.Format
        d.HMACLen = rd.HMACLen
        if rd.HMAC != nil </span><span class="cov0" title="0">{
                d.HMAC = make([]byte, len(rd.HMAC))
                copy(d.HMAC, rd.HMAC)
        }</span> else<span class="cov0" title="0"> {
                d.HMAC = nil
        }</span>
        <span class="cov0" title="0">d.Sequence = rd.Sequence
        d.Total = rd.Total
        d.DataLength = rd.DataLength
        if rd.Data != nil </span><span class="cov0" title="0">{
                d.Data = make([]byte, len(rd.Data))
                copy(d.Data, rd.Data)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (rd *CHUNK2) Len() int <span class="cov0" title="0">{
        return 1 + // format
                2 + // hmac length
                int(rd.HMACLen) + // hmac (variable)
                2 + // sequence
                2 + // total
                2 + // data length
                len(rd.Data) // data
}</span>

func RegisterCHUNK2RR() error <span class="cov8" title="1">{
        dns.PrivateHandle("CHUNK2", TypeCHUNK2, NewCHUNK2)
        // Explicitly set TypeToString to use "CHUNK2" for printing
        dns.TypeToString[TypeCHUNK2] = "CHUNK2"
        return nil
}</span>

</pre>
		
		<pre class="file" id="file4" style="display: none">/*
 * Copyright (c) 2024 Johan Stenstam, johani@johani.org
 */

package core

import (
        "encoding/binary"
        "errors"
)

const TypeDSYNC = 0x0042 // 66 is the official IANA code
// const TypeDSYNC = 0x0F9B

const (
        TypeNOTIFY  = 0x0F9A
        TypeMSIGNER = 0x0F9C
        TypeHSYNC   = 0x0F9D
        TypeHSYNC2  = 0x0F9E
        TypeTSYNC   = 0x0F9F
        TypeMANIFEST = 65013 // 0xFDF5 - Distribution Manifest
        TypeCHUNK    = 65014 // 0xFDF6 - Chunked Data Transport
        TypeCHUNK2   = 65015 // 0xFDF7 - Unified Chunk/Manifest (experimental)
)

// Format constants for MANIFEST and CHUNK RR types
const (
        FormatJSON = 1 // JSON format (original format)
        // Future formats can be added as needed:
        // FormatJSONv2 = 9  // Example: if JSON v2 is needed in the future
        // FormatBinary = 2  // Example: binary format
        // FormatProtobuf = 3 // Example: protobuf format
)

// FormatToString maps format constants to their string representations
var FormatToString = map[uint8]string{
        FormatJSON: "JSON",
        // Future formats:
        // FormatJSONv2: "JSONv2",
        // FormatBinary: "BINARY",
        // FormatProtobuf: "PROTOBUF",
}

// StringToFormat maps string representations to format constants (reverse of FormatToString)
// NOTE: This map must be kept in sync with FormatToString - when adding a new format to FormatToString,
// also add the corresponding entry here.
var StringToFormat = map[string]uint8{
        "JSON": FormatJSON,
        // Future formats will be added here when FormatToString is updated:
        // "JSONv2": FormatJSONv2,
        // "BINARY": FormatBinary,
        // "PROTOBUF": FormatProtobuf,
}

func unpackUint8(msg []byte, off int) (i uint8, off1 int, err error) <span class="cov0" title="0">{
        if off+1 &gt; len(msg) </span><span class="cov0" title="0">{
                return 0, len(msg), errors.New("overflow unpacking uint8")
        }</span>
        <span class="cov0" title="0">return msg[off], off + 1, nil</span>
}

func packUint8(i uint8, msg []byte, off int) (off1 int, err error) <span class="cov0" title="0">{
        if off+1 &gt; len(msg) </span><span class="cov0" title="0">{
                return len(msg), errors.New("overflow packing uint8")
        }</span>
        <span class="cov0" title="0">msg[off] = i
        return off + 1, nil</span>
}

func unpackUint16(msg []byte, off int) (i uint16, off1 int, err error) <span class="cov0" title="0">{
        if off+2 &gt; len(msg) </span><span class="cov0" title="0">{
                return 0, len(msg), errors.New("overflow unpacking uint16")
        }</span>
        <span class="cov0" title="0">return binary.BigEndian.Uint16(msg[off:]), off + 2, nil</span>
}

func packUint16(i uint16, msg []byte, off int) (off1 int, err error) <span class="cov0" title="0">{
        if off+2 &gt; len(msg) </span><span class="cov0" title="0">{
                return len(msg), errors.New("overflow packing uint16")
        }</span>
        <span class="cov0" title="0">binary.BigEndian.PutUint16(msg[off:], i)
        return off + 2, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
 * Copyright (c) Johan Stenstam, johan.stenstam@internetstiftelsen.se
 */

package core

import (
        "bytes"
        "encoding/binary"
        "errors"
        "fmt"
        "net"
        "sort"
        "strconv"
        "strings"

        "github.com/miekg/dns"
)

func init() <span class="cov8" title="1">{
        RegisterDelegRR()
}</span>

// SVCBKey is the type of the keys used in the SVCB RR.
type DELEGKey uint16

// Keys defined in rfc9460
const (
        DELEG_MANDATORY DELEGKey = iota
        DELEG_ALPN
        DELEG_NO_DEFAULT_ALPN
        DELEG_PORT
        DELEG_IPV4HINT
        DELEG_ECHCONFIG
        DELEG_IPV6HINT
        DELEG_DOHPATH // rfc9461 Section 5
        DELEG_OHTTP   // rfc9540 Section 8

        deleg_RESERVED DELEGKey = 65535
)

var delegKeyToStringMap = map[DELEGKey]string{
        DELEG_MANDATORY:       "mandatory",
        DELEG_ALPN:            "alpn",
        DELEG_NO_DEFAULT_ALPN: "no-default-alpn",
        DELEG_PORT:            "port",
        DELEG_IPV4HINT:        "ipv4hint",
        //        DELEG_ECHCONFIG:       "ech",
        DELEG_IPV6HINT: "ipv6hint",
        // DELEG_DOHPATH:         "dohpath",
        // DELEG_OHTTP:           "ohttp",
}

var delegStringToKeyMap = reverseDELEGKeyMap(delegKeyToStringMap)

func reverseDELEGKeyMap(m map[DELEGKey]string) map[string]DELEGKey <span class="cov8" title="1">{
        n := make(map[string]DELEGKey, len(m))
        for u, s := range m </span><span class="cov8" title="1">{
                n[s] = u
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (key DELEGKey) String() string <span class="cov0" title="0">{
        if x := delegKeyToStringMap[key]; x != "" </span><span class="cov0" title="0">{
                return x
        }</span>
        <span class="cov0" title="0">if key == deleg_RESERVED </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return "key" + strconv.FormatUint(uint64(key), 10)</span>
}

func delegStringToKey(s string) DELEGKey <span class="cov0" title="0">{
        if strings.HasPrefix(s, "key") </span><span class="cov0" title="0">{
                a, err := strconv.ParseUint(s[3:], 10, 16)
                // no leading zeros
                // key shouldn't be registered
                if err != nil || a == 65535 || s[3] == '0' || delegKeyToStringMap[DELEGKey(a)] != "" </span><span class="cov0" title="0">{
                        return deleg_RESERVED
                }</span>
                <span class="cov0" title="0">return DELEGKey(a)</span>
        }
        <span class="cov0" title="0">if key, ok := delegStringToKeyMap[s]; ok </span><span class="cov0" title="0">{
                return key
        }</span>
        <span class="cov0" title="0">return deleg_RESERVED</span>
}

// johani
func (rr *DELEG) Parse(s []string) error <span class="cov8" title="1">{
        zl := newZLexer(strings.NewReader(strings.Join(s, " ")))
        pe := rr.parse(zl, "")
        if pe != nil </span><span class="cov0" title="0">{
                return errors.New(pe.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (rr *DELEG) parse(c *zlexer, o string) *ParseError <span class="cov8" title="1">{
        l, _ := c.Next()
        i, e := strconv.ParseUint(l.token, 10, 16)
        if e != nil || l.err </span><span class="cov0" title="0">{
                return &amp;ParseError{file: l.token, err: "bad DELEG priority", lex: l}
        }</span>
        <span class="cov8" title="1">rr.Priority = uint16(i)

        c.Next()        // zBlank
        l, _ = c.Next() // zString
        rr.Target = l.token

        name, nameOk := toAbsoluteName(l.token, o)
        if l.err || !nameOk </span><span class="cov0" title="0">{
                return &amp;ParseError{file: l.token, err: "bad DELEG Target", lex: l}
        }</span>
        <span class="cov8" title="1">rr.Target = name

        // Values (if any)
        l, _ = c.Next()
        var xs []DELEGKeyValue
        // Helps require whitespace between pairs.
        // Prevents key1000="a"key1001=...
        canHaveNextKey := true
        for l.value != zNewline &amp;&amp; l.value != zEOF </span><span class="cov0" title="0">{
                switch l.value </span>{
                case zString:<span class="cov0" title="0">
                        if !canHaveNextKey </span><span class="cov0" title="0">{
                                // The key we can now read was probably meant to be
                                // a part of the last value.
                                return &amp;ParseError{file: l.token, err: "bad DELEG value quotation", lex: l}
                        }</span>

                        // In key=value pairs, value does not have to be quoted unless value
                        // contains whitespace. And keys don't need to have values.
                        // Similarly, keys with an equality signs after them don't need values.
                        // l.token includes at least up to the first equality sign.
                        <span class="cov0" title="0">idx := strings.IndexByte(l.token, '=')
                        var key, value string
                        if idx &lt; 0 </span><span class="cov0" title="0">{
                                // Key with no value and no equality sign
                                key = l.token
                        }</span> else<span class="cov0" title="0"> if idx == 0 </span><span class="cov0" title="0">{
                                return &amp;ParseError{file: l.token, err: "bad DELEG key", lex: l}
                        }</span> else<span class="cov0" title="0"> {
                                key, value = l.token[:idx], l.token[idx+1:]

                                if value == "" </span><span class="cov0" title="0">{
                                        // We have a key and an equality sign. Maybe we have nothing
                                        // after "=" or we have a double quote.
                                        l, _ = c.Next()
                                        if l.value == zQuote </span><span class="cov0" title="0">{
                                                // Only needed when value ends with double quotes.
                                                // Any value starting with zQuote ends with it.
                                                canHaveNextKey = false

                                                l, _ = c.Next()
                                                switch l.value </span>{
                                                case zString:<span class="cov0" title="0">
                                                        // We have a value in double quotes.
                                                        value = l.token
                                                        l, _ = c.Next()
                                                        if l.value != zQuote </span><span class="cov0" title="0">{
                                                                return &amp;ParseError{file: l.token, err: "DELEG unterminated value", lex: l}
                                                        }</span>
                                                case zQuote:<span class="cov0" title="0"></span>
                                                        // There's nothing in double quotes.
                                                default:<span class="cov0" title="0">
                                                        return &amp;ParseError{file: l.token, err: "bad DELEG value", lex: l}</span>
                                                }
                                        }
                                }
                        }
                        <span class="cov0" title="0">kv := makeDELEGKeyValue(delegStringToKey(key))
                        if kv == nil </span><span class="cov0" title="0">{
                                return &amp;ParseError{file: l.token, err: "bad DELEG key", lex: l}
                        }</span>
                        <span class="cov0" title="0">if err := kv.parse(value); err != nil </span><span class="cov0" title="0">{
                                return &amp;ParseError{file: l.token, wrappedErr: err, lex: l}
                        }</span>
                        <span class="cov0" title="0">xs = append(xs, kv)</span>
                case zQuote:<span class="cov0" title="0">
                        return &amp;ParseError{file: l.token, err: "DELEG key can't contain double quotes", lex: l}</span>
                case zBlank:<span class="cov0" title="0">
                        canHaveNextKey = true</span>
                default:<span class="cov0" title="0">
                        return &amp;ParseError{file: l.token, err: "bad DELEG values", lex: l}</span>
                }
                <span class="cov0" title="0">l, _ = c.Next()</span>
        }

        // "In AliasMode, records SHOULD NOT include any SvcParams, and recipients MUST
        // ignore any SvcParams that are present."
        // However, we don't check rr.Priority == 0 &amp;&amp; len(xs) &gt; 0 here
        // It is the responsibility of the user of the library to check this.
        // This is to encourage the fixing of the source of this error.

        <span class="cov8" title="1">rr.Value = xs
        return nil</span>
}

// makeSVCBKeyValue returns an SVCBKeyValue struct with the key or nil for reserved keys.
func makeDELEGKeyValue(key DELEGKey) DELEGKeyValue <span class="cov0" title="0">{
        switch key </span>{
        case DELEG_MANDATORY:<span class="cov0" title="0">
                return new(DELEGMandatory)</span>
        case DELEG_ALPN:<span class="cov0" title="0">
                return new(DELEGAlpn)</span>
        case DELEG_NO_DEFAULT_ALPN:<span class="cov0" title="0">
                return new(DELEGNoDefaultAlpn)</span>
        case DELEG_PORT:<span class="cov0" title="0">
                return new(DELEGPort)</span>
        case DELEG_IPV4HINT:<span class="cov0" title="0">
                return new(DELEGIPv4Hint)</span>
        //case DELEG_ECHCONFIG:
        //        return new(DELEGECHConfig)
        case DELEG_IPV6HINT:<span class="cov0" title="0">
                return new(DELEGIPv6Hint)</span>
        //case DELEG_DOHPATH:
        //        return new(DELEGDoHPath)
        //case DELEG_OHTTP:
        //        return new(DELEGOhttp)
        case deleg_RESERVED:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                e := new(DELEGLocal)
                e.KeyCode = key
                return e</span>
        }
}

type DELEG struct {
        // Hdr      dns.RR_Header
        Priority uint16          // If zero, Value must be empty or discarded by the user of this library
        Target   string          `dns:"domain-name"`
        Value    []DELEGKeyValue `dns:"pairs"`
}

const TypeDELEG = 65287

func NewDELEG() dns.PrivateRdata <span class="cov0" title="0">{ return new(DELEG) }</span>

func (rr *DELEG) Copy(dest dns.PrivateRdata) error <span class="cov0" title="0">{
        d := dest.(*DELEG)
        d.Value = make([]DELEGKeyValue, len(rr.Value))
        for i, e := range rr.Value </span><span class="cov0" title="0">{
                d.Value[i] = e.copy()
        }</span>

        <span class="cov0" title="0">d.Priority = rr.Priority
        d.Target = rr.Target
        return nil</span>
}

// johani
func (rr *DELEG) Len() int <span class="cov0" title="0">{
        l := 2 // Priority
        l += len(rr.Target) + 1
        for _, x := range rr.Value </span><span class="cov0" title="0">{
                l += 4 + int(x.len())
        }</span>
        <span class="cov0" title="0">return l</span>
}

// johani
func (rr *DELEG) Pack(buf []byte) (int, error) <span class="cov0" title="0">{
        var off int
        var err error
        off, err = packUint16(rr.Priority, buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">off, err = dns.PackDomainName(rr.Target, buf, off, nil, true)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">off, err = packDelegData(rr.Value, buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        // log.Printf("DEBUG DELEG.Pack: final off = %d, buf=%v (string: %s)", off, buf, string(buf))
        <span class="cov0" title="0">return off, nil</span>
}

func (rr *DELEG) Unpack(buf []byte) (int, error) <span class="cov0" title="0">{
        // log.Printf("DEBUG DELEG.Unpack: buf=%v (string: %s)", buf, string(buf))
        var off int
        var err error
        rr.Priority, off, err = unpackUint16(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">if off == len(buf) </span><span class="cov0" title="0">{
                return off, nil
        }</span>
        <span class="cov0" title="0">rr.Target, off, err = dns.UnpackDomainName(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">if off == len(buf) </span><span class="cov0" title="0">{
                return off, nil
        }</span>
        <span class="cov0" title="0">rr.Value, off, err = unpackDelegData(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">return off, nil</span>
}

// johani
func RegisterDelegRR() error <span class="cov8" title="1">{
        dns.PrivateHandle("DELEG", TypeDELEG, NewDELEG)
        dns.TypeToString[TypeDELEG] = "DELEG"
        return nil
}</span>

func packDelegData(pairs []DELEGKeyValue, msg []byte, off int) (int, error) <span class="cov0" title="0">{
        pairs = cloneSlice(pairs)
        sort.Slice(pairs, func(i, j int) bool </span><span class="cov0" title="0">{
                return pairs[i].Key() &lt; pairs[j].Key()
        }</span>)
        <span class="cov0" title="0">prev := deleg_RESERVED
        for _, el := range pairs </span><span class="cov0" title="0">{
                if el.Key() == prev </span><span class="cov0" title="0">{
                        return len(msg), errors.New("repeated DELEG keys are not allowed")
                }</span>
                <span class="cov0" title="0">prev = el.Key()
                packed, err := el.pack()
                if err != nil </span><span class="cov0" title="0">{
                        return len(msg), err
                }</span>
                <span class="cov0" title="0">off, err = packUint16(uint16(el.Key()), msg, off)
                if err != nil </span><span class="cov0" title="0">{
                        return len(msg), errors.New("overflow packing DELEG")
                }</span>
                <span class="cov0" title="0">off, err = packUint16(uint16(len(packed)), msg, off)
                if err != nil || off+len(packed) &gt; len(msg) </span><span class="cov0" title="0">{
                        return len(msg), errors.New("overflow packing DELEG")
                }</span>
                <span class="cov0" title="0">copy(msg[off:off+len(packed)], packed)
                off += len(packed)</span>
        }
        <span class="cov0" title="0">return off, nil</span>
}

func unpackDelegData(msg []byte, off int) ([]DELEGKeyValue, int, error) <span class="cov0" title="0">{
        var xs []DELEGKeyValue
        var code uint16
        var length uint16
        var err error
        for off &lt; len(msg) </span><span class="cov0" title="0">{
                code, off, err = unpackUint16(msg, off)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, len(msg), errors.New("overflow unpacking DELEG")
                }</span>
                <span class="cov0" title="0">length, off, err = unpackUint16(msg, off)
                if err != nil || off+int(length) &gt; len(msg) </span><span class="cov0" title="0">{
                        return nil, len(msg), errors.New("overflow unpacking DELEG")
                }</span>
                <span class="cov0" title="0">e := makeDELEGKeyValue(DELEGKey(code))
                if e == nil </span><span class="cov0" title="0">{
                        return nil, len(msg), errors.New("bad DELEG key")
                }</span>
                <span class="cov0" title="0">if err := e.unpack(msg[off : off+int(length)]); err != nil </span><span class="cov0" title="0">{
                        return nil, len(msg), err
                }</span>
                <span class="cov0" title="0">if len(xs) &gt; 0 &amp;&amp; e.Key() &lt;= xs[len(xs)-1].Key() </span><span class="cov0" title="0">{
                        return nil, len(msg), errors.New("DELEG keys not in strictly increasing order")
                }</span>
                <span class="cov0" title="0">xs = append(xs, e)
                off += int(length)</span>
        }
        <span class="cov0" title="0">return xs, off, nil</span>
}

// DELEGKeyValue defines a key=value pair for the DELEG RR type.
// A DELEG RR can have multiple DELEGKeyValues appended to it.
type DELEGKeyValue interface {
        Key() DELEGKey         // Key returns the numerical key code.
        pack() ([]byte, error) // pack returns the encoded value.
        unpack([]byte) error   // unpack sets the value.
        String() string        // String returns the string representation of the value.
        parse(string) error    // parse sets the value to the given string representation of the value.
        copy() DELEGKeyValue   // copy returns a deep-copy of the pair.
        len() int              // len returns the length of value in the wire format.
}

// SVCBMandatory pair adds to required keys that must be interpreted for the RR
// to be functional. If ignored, the whole RRSet must be ignored.
// "port" and "no-default-alpn" are mandatory by default if present,
// so they shouldn't be included here.
//
// It is incumbent upon the user of this library to reject the RRSet if
// or avoid constructing such an RRSet that:
// - "mandatory" is included as one of the keys of mandatory
// - no key is listed multiple times in mandatory
// - all keys listed in mandatory are present
// - escape sequences are not used in mandatory
// - mandatory, when present, lists at least one key
//
// Basic use pattern for creating a mandatory option:
//
//        s := &amp;dns.SVCB{Hdr: dns.RR_Header{Name: ".", Rrtype: dns.TypeSVCB, Class: dns.ClassINET}}
//        e := new(dns.SVCBMandatory)
//        e.Code = []uint16{dns.SVCB_ALPN}
//        s.Value = append(s.Value, e)
//        t := new(dns.SVCBAlpn)
//        t.Alpn = []string{"xmpp-client"}
//        s.Value = append(s.Value, t)
type DELEGMandatory struct {
        Code []DELEGKey
}

func (*DELEGMandatory) Key() DELEGKey <span class="cov0" title="0">{ return DELEG_MANDATORY }</span>

func (s *DELEGMandatory) String() string <span class="cov0" title="0">{
        str := make([]string, len(s.Code))
        for i, e := range s.Code </span><span class="cov0" title="0">{
                str[i] = e.String()
        }</span>
        <span class="cov0" title="0">return strings.Join(str, ",")</span>
}

func (s *DELEGMandatory) pack() ([]byte, error) <span class="cov0" title="0">{
        codes := cloneSlice(s.Code)
        sort.Slice(codes, func(i, j int) bool </span><span class="cov0" title="0">{
                return codes[i] &lt; codes[j]
        }</span>)
        <span class="cov0" title="0">b := make([]byte, 2*len(codes))
        for i, e := range codes </span><span class="cov0" title="0">{
                binary.BigEndian.PutUint16(b[2*i:], uint16(e))
        }</span>
        <span class="cov0" title="0">return b, nil</span>
}

func (s *DELEGMandatory) unpack(b []byte) error <span class="cov0" title="0">{
        if len(b)%2 != 0 </span><span class="cov0" title="0">{
                return errors.New("dns: delegmandatory: value length is not a multiple of 2")
        }</span>
        <span class="cov0" title="0">codes := make([]DELEGKey, 0, len(b)/2)
        for i := 0; i &lt; len(b); i += 2 </span><span class="cov0" title="0">{
                // We assume strictly increasing order.
                codes = append(codes, DELEGKey(binary.BigEndian.Uint16(b[i:])))
        }</span>
        <span class="cov0" title="0">s.Code = codes
        return nil</span>
}

func (s *DELEGMandatory) parse(b string) error <span class="cov0" title="0">{
        codes := make([]DELEGKey, 0, strings.Count(b, ",")+1)
        for len(b) &gt; 0 </span><span class="cov0" title="0">{
                var key string
                key, b, _ = strings.Cut(b, ",")
                codes = append(codes, delegStringToKey(key))
        }</span>
        <span class="cov0" title="0">s.Code = codes
        return nil</span>
}

func (s *DELEGMandatory) len() int <span class="cov0" title="0">{
        return 2 * len(s.Code)
}</span>

func (s *DELEGMandatory) copy() DELEGKeyValue <span class="cov0" title="0">{
        return &amp;DELEGMandatory{cloneSlice(s.Code)}
}</span>

// SVCBAlpn pair is used to list supported connection protocols.
// The user of this library must ensure that at least one protocol is listed when alpn is present.
// Protocol IDs can be found at:
// https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids
// Basic use pattern for creating an alpn option:
//
//        h := new(dns.HTTPS)
//        h.Hdr = dns.RR_Header{Name: ".", Rrtype: dns.TypeHTTPS, Class: dns.ClassINET}
//        e := new(dns.SVCBAlpn)
//        e.Alpn = []string{"h2", "http/1.1"}
//        h.Value = append(h.Value, e)
type DELEGAlpn struct {
        Alpn []string
}

func (*DELEGAlpn) Key() DELEGKey <span class="cov0" title="0">{ return DELEG_ALPN }</span>

func (s *DELEGAlpn) String() string <span class="cov0" title="0">{
        // An ALPN value is a comma-separated list of values, each of which can be
        // an arbitrary binary value. In order to allow parsing, the comma and
        // backslash characters are themselves escaped.
        //
        // However, this escaping is done in addition to the normal escaping which
        // happens in zone files, meaning that these values must be
        // double-escaped. This looks terrible, so if you see a never-ending
        // sequence of backslash in a zone file this may be why.
        //
        // https://datatracker.ietf.org/doc/html/draft-ietf-dnsop-svcb-https-08#appendix-A.1
        var str strings.Builder
        for i, alpn := range s.Alpn </span><span class="cov0" title="0">{
                // 4*len(alpn) is the worst case where we escape every character in the alpn as \123, plus 1 byte for the ',' separating the alpn from others
                str.Grow(4*len(alpn) + 1)
                if i &gt; 0 </span><span class="cov0" title="0">{
                        str.WriteByte(',')
                }</span>
                <span class="cov0" title="0">for j := 0; j &lt; len(alpn); j++ </span><span class="cov0" title="0">{
                        e := alpn[j]
                        if ' ' &gt; e || e &gt; '~' </span><span class="cov0" title="0">{
                                str.WriteString(escapeByte(e))
                                continue</span>
                        }
                        <span class="cov0" title="0">switch e </span>{
                        // We escape a few characters which may confuse humans or parsers.
                        case '"', ';', ' ':<span class="cov0" title="0">
                                str.WriteByte('\\')
                                str.WriteByte(e)</span>
                        // The comma and backslash characters themselves must be
                        // doubly-escaped. We use `\\` for the first backslash and
                        // the escaped numeric value for the other value. We especially
                        // don't want a comma in the output.
                        case ',':<span class="cov0" title="0">
                                str.WriteString(`\\\044`)</span>
                        case '\\':<span class="cov0" title="0">
                                str.WriteString(`\\\092`)</span>
                        default:<span class="cov0" title="0">
                                str.WriteByte(e)</span>
                        }
                }
        }
        <span class="cov0" title="0">return str.String()</span>
}

func (s *DELEGAlpn) pack() ([]byte, error) <span class="cov0" title="0">{
        // Liberally estimate the size of an alpn as 10 octets
        b := make([]byte, 0, 10*len(s.Alpn))
        for _, e := range s.Alpn </span><span class="cov0" title="0">{
                if e == "" </span><span class="cov0" title="0">{
                        return nil, errors.New("dns: delegalpn: empty alpn-id")
                }</span>
                <span class="cov0" title="0">if len(e) &gt; 255 </span><span class="cov0" title="0">{
                        return nil, errors.New("dns: delegalpn: alpn-id too long")
                }</span>
                <span class="cov0" title="0">b = append(b, byte(len(e)))
                b = append(b, e...)</span>
        }
        <span class="cov0" title="0">return b, nil</span>
}

func (s *DELEGAlpn) unpack(b []byte) error <span class="cov0" title="0">{
        // Estimate the size of the smallest alpn as 4 bytes
        alpn := make([]string, 0, len(b)/4)
        for i := 0; i &lt; len(b); </span><span class="cov0" title="0">{
                length := int(b[i])
                i++
                if i+length &gt; len(b) </span><span class="cov0" title="0">{
                        return errors.New("dns: delegalpn: alpn array overflowing")
                }</span>
                <span class="cov0" title="0">alpn = append(alpn, string(b[i:i+length]))
                i += length</span>
        }
        <span class="cov0" title="0">s.Alpn = alpn
        return nil</span>
}

func (s *DELEGAlpn) parse(b string) error <span class="cov0" title="0">{
        if len(b) == 0 </span><span class="cov0" title="0">{
                s.Alpn = []string{}
                return nil
        }</span>

        <span class="cov0" title="0">alpn := []string{}
        a := []byte{}
        for p := 0; p &lt; len(b); </span><span class="cov0" title="0">{
                c, q := nextByte(b, p)
                if q == 0 </span><span class="cov0" title="0">{
                        return errors.New("dns: delegalpn: unterminated escape")
                }</span>
                <span class="cov0" title="0">p += q
                // If we find a comma, we have finished reading an alpn.
                if c == ',' </span><span class="cov0" title="0">{
                        if len(a) == 0 </span><span class="cov0" title="0">{
                                return errors.New("dns: delegalpn: empty protocol identifier")
                        }</span>
                        <span class="cov0" title="0">alpn = append(alpn, string(a))
                        a = []byte{}
                        continue</span>
                }
                // If it's a backslash, we need to handle a comma-separated list.
                <span class="cov0" title="0">if c == '\\' </span><span class="cov0" title="0">{
                        dc, dq := nextByte(b, p)
                        if dq == 0 </span><span class="cov0" title="0">{
                                return errors.New("dns: delegalpn: unterminated escape decoding comma-separated list")
                        }</span>
                        <span class="cov0" title="0">if dc != '\\' &amp;&amp; dc != ',' </span><span class="cov0" title="0">{
                                return errors.New("dns: delegalpn: bad escaped character decoding comma-separated list")
                        }</span>
                        <span class="cov0" title="0">p += dq
                        c = dc</span>
                }
                <span class="cov0" title="0">a = append(a, c)</span>
        }
        // Add the final alpn.
        <span class="cov0" title="0">if len(a) == 0 </span><span class="cov0" title="0">{
                return errors.New("dns: delegalpn: last protocol identifier empty")
        }</span>
        <span class="cov0" title="0">s.Alpn = append(alpn, string(a))
        return nil</span>
}

func (s *DELEGAlpn) len() int <span class="cov0" title="0">{
        var l int
        for _, e := range s.Alpn </span><span class="cov0" title="0">{
                l += 1 + len(e)
        }</span>
        <span class="cov0" title="0">return l</span>
}

func (s *DELEGAlpn) copy() DELEGKeyValue <span class="cov0" title="0">{
        return &amp;DELEGAlpn{cloneSlice(s.Alpn)}
}</span>

// SVCBNoDefaultAlpn pair signifies no support for default connection protocols.
// Should be used in conjunction with alpn.
// Basic use pattern for creating a no-default-alpn option:
//
//        s := &amp;dns.SVCB{Hdr: dns.RR_Header{Name: ".", Rrtype: dns.TypeSVCB, Class: dns.ClassINET}}
//        t := new(dns.SVCBAlpn)
//        t.Alpn = []string{"xmpp-client"}
//        s.Value = append(s.Value, t)
//        e := new(dns.SVCBNoDefaultAlpn)
//        s.Value = append(s.Value, e)
type DELEGNoDefaultAlpn struct{}

func (*DELEGNoDefaultAlpn) Key() DELEGKey         <span class="cov0" title="0">{ return DELEG_NO_DEFAULT_ALPN }</span>
func (*DELEGNoDefaultAlpn) copy() DELEGKeyValue   <span class="cov0" title="0">{ return &amp;DELEGNoDefaultAlpn{} }</span>
func (*DELEGNoDefaultAlpn) pack() ([]byte, error) <span class="cov0" title="0">{ return []byte{}, nil }</span>
func (*DELEGNoDefaultAlpn) String() string        <span class="cov0" title="0">{ return "" }</span>
func (*DELEGNoDefaultAlpn) len() int              <span class="cov0" title="0">{ return 0 }</span>

func (*DELEGNoDefaultAlpn) unpack(b []byte) error <span class="cov0" title="0">{
        if len(b) != 0 </span><span class="cov0" title="0">{
                return errors.New("dns: svcbnodefaultalpn: no-default-alpn must have no value")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (*DELEGNoDefaultAlpn) parse(b string) error <span class="cov0" title="0">{
        if b != "" </span><span class="cov0" title="0">{
                return errors.New("dns: delegnodefaultalpn: no-default-alpn must have no value")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SVCBPort pair defines the port for connection.
// Basic use pattern for creating a port option:
//
//        s := &amp;dns.SVCB{Hdr: dns.RR_Header{Name: ".", Rrtype: dns.TypeSVCB, Class: dns.ClassINET}}
//        e := new(dns.SVCBPort)
//        e.Port = 80
//        s.Value = append(s.Value, e)
type DELEGPort struct {
        Port uint16
}

func (*DELEGPort) Key() DELEGKey         <span class="cov0" title="0">{ return DELEG_PORT }</span>
func (*DELEGPort) len() int              <span class="cov0" title="0">{ return 2 }</span>
func (s *DELEGPort) String() string      <span class="cov0" title="0">{ return strconv.FormatUint(uint64(s.Port), 10) }</span>
func (s *DELEGPort) copy() DELEGKeyValue <span class="cov0" title="0">{ return &amp;DELEGPort{s.Port} }</span>

func (s *DELEGPort) unpack(b []byte) error <span class="cov0" title="0">{
        if len(b) != 2 </span><span class="cov0" title="0">{
                return errors.New("dns: delegport: port length is not exactly 2 octets")
        }</span>
        <span class="cov0" title="0">s.Port = binary.BigEndian.Uint16(b)
        return nil</span>
}

func (s *DELEGPort) pack() ([]byte, error) <span class="cov0" title="0">{
        b := make([]byte, 2)
        binary.BigEndian.PutUint16(b, s.Port)
        return b, nil
}</span>

func (s *DELEGPort) parse(b string) error <span class="cov0" title="0">{
        port, err := strconv.ParseUint(b, 10, 16)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("dns: delegport: port out of range")
        }</span>
        <span class="cov0" title="0">s.Port = uint16(port)
        return nil</span>
}

// SVCBIPv4Hint pair suggests an IPv4 address which may be used to open connections
// if A and AAAA record responses for SVCB's Target domain haven't been received.
// In that case, optionally, A and AAAA requests can be made, after which the connection
// to the hinted IP address may be terminated and a new connection may be opened.
// Basic use pattern for creating an ipv4hint option:
//
//                h := new(dns.HTTPS)
//                h.Hdr = dns.RR_Header{Name: ".", Rrtype: dns.TypeHTTPS, Class: dns.ClassINET}
//                e := new(dns.SVCBIPv4Hint)
//                e.Hint = []net.IP{net.IPv4(1,1,1,1).To4()}
//
//         Or
//
//                e.Hint = []net.IP{net.ParseIP("1.1.1.1").To4()}
//                h.Value = append(h.Value, e)
type DELEGIPv4Hint struct {
        Hint []net.IP
}

func (*DELEGIPv4Hint) Key() DELEGKey <span class="cov0" title="0">{ return DELEG_IPV4HINT }</span>
func (s *DELEGIPv4Hint) len() int    <span class="cov0" title="0">{ return 4 * len(s.Hint) }</span>

func (s *DELEGIPv4Hint) pack() ([]byte, error) <span class="cov0" title="0">{
        b := make([]byte, 0, 4*len(s.Hint))
        for _, e := range s.Hint </span><span class="cov0" title="0">{
                x := e.To4()
                if x == nil </span><span class="cov0" title="0">{
                        return nil, errors.New("dns: delegipv4hint: expected ipv4, hint is ipv6")
                }</span>
                <span class="cov0" title="0">b = append(b, x...)</span>
        }
        <span class="cov0" title="0">return b, nil</span>
}

func (s *DELEGIPv4Hint) unpack(b []byte) error <span class="cov0" title="0">{
        if len(b) == 0 || len(b)%4 != 0 </span><span class="cov0" title="0">{
                return errors.New("dns: delegipv4hint: ipv4 address byte array length is not a multiple of 4")
        }</span>
        <span class="cov0" title="0">b = cloneSlice(b)
        x := make([]net.IP, 0, len(b)/4)
        for i := 0; i &lt; len(b); i += 4 </span><span class="cov0" title="0">{
                x = append(x, net.IP(b[i:i+4]))
        }</span>
        <span class="cov0" title="0">s.Hint = x
        return nil</span>
}

func (s *DELEGIPv4Hint) String() string <span class="cov0" title="0">{
        str := make([]string, len(s.Hint))
        for i, e := range s.Hint </span><span class="cov0" title="0">{
                x := e.To4()
                if x == nil </span><span class="cov0" title="0">{
                        return "&lt;nil&gt;"
                }</span>
                <span class="cov0" title="0">str[i] = x.String()</span>
        }
        <span class="cov0" title="0">return strings.Join(str, ",")</span>
}

func (s *DELEGIPv4Hint) parse(b string) error <span class="cov0" title="0">{
        if b == "" </span><span class="cov0" title="0">{
                return errors.New("dns: delegipv4hint: empty hint")
        }</span>
        <span class="cov0" title="0">if strings.Contains(b, ":") </span><span class="cov0" title="0">{
                return errors.New("dns: delegipv4hint: expected ipv4, got ipv6")
        }</span>

        <span class="cov0" title="0">hint := make([]net.IP, 0, strings.Count(b, ",")+1)
        for len(b) &gt; 0 </span><span class="cov0" title="0">{
                var e string
                e, b, _ = strings.Cut(b, ",")
                ip := net.ParseIP(e).To4()
                if ip == nil </span><span class="cov0" title="0">{
                        return errors.New("dns: delegipv4hint: bad ip")
                }</span>
                <span class="cov0" title="0">hint = append(hint, ip)</span>
        }
        <span class="cov0" title="0">s.Hint = hint
        return nil</span>
}

func (s *DELEGIPv4Hint) copy() DELEGKeyValue <span class="cov0" title="0">{
        hint := make([]net.IP, len(s.Hint))
        for i, ip := range s.Hint </span><span class="cov0" title="0">{
                hint[i] = cloneSlice(ip)
        }</span>
        <span class="cov0" title="0">return &amp;DELEGIPv4Hint{Hint: hint}</span>
}

// SVCBECHConfig pair contains the ECHConfig structure defined in draft-ietf-tls-esni [RFC xxxx].
// Basic use pattern for creating an ech option:
//
//        h := new(dns.HTTPS)
//        h.Hdr = dns.RR_Header{Name: ".", Rrtype: dns.TypeHTTPS, Class: dns.ClassINET}
//        e := new(dns.SVCBECHConfig)
//        e.ECH = []byte{0xfe, 0x08, ...}
//        h.Value = append(h.Value, e)
// type DELEGECHConfig struct {
//         ECH []byte // Specifically ECHConfigList including the redundant length prefix
// }

// func (*DELEGECHConfig) Key() DELEGKey     { return DELEG_ECHCONFIG }
// func (s *DELEGECHConfig) String() string { return toBase64(s.ECH) }
// func (s *DELEGECHConfig) len() int       { return len(s.ECH) }

// func (s *DELEGECHConfig) pack() ([]byte, error) {
//         return cloneSlice(s.ECH), nil
// }

// func (s *DELEGECHConfig) copy() DELEGKeyValue {
//         return &amp;DELEGECHConfig{cloneSlice(s.ECH)}
// }

// func (s *DELEGECHConfig) unpack(b []byte) error {
//         s.ECH = cloneSlice(b)
//         return nil
// }

// func (s *SVCBECHConfig) parse(b string) error {
//         x, err := fromBase64([]byte(b))
//         if err != nil {
//                 return errors.New("dns: svcbech: bad base64 ech")
//         }
//         s.ECH = x
//         return nil
// }

// SVCBIPv6Hint pair suggests an IPv6 address which may be used to open connections
// if A and AAAA record responses for SVCB's Target domain haven't been received.
// In that case, optionally, A and AAAA requests can be made, after which the
// connection to the hinted IP address may be terminated and a new connection may be opened.
// Basic use pattern for creating an ipv6hint option:
//
//        h := new(dns.HTTPS)
//        h.Hdr = dns.RR_Header{Name: ".", Rrtype: dns.TypeHTTPS, Class: dns.ClassINET}
//        e := new(dns.SVCBIPv6Hint)
//        e.Hint = []net.IP{net.ParseIP("2001:db8::1")}
//        h.Value = append(h.Value, e)
type DELEGIPv6Hint struct {
        Hint []net.IP
}

func (*DELEGIPv6Hint) Key() DELEGKey <span class="cov0" title="0">{ return DELEG_IPV6HINT }</span>
func (s *DELEGIPv6Hint) len() int    <span class="cov0" title="0">{ return 16 * len(s.Hint) }</span>

func (s *DELEGIPv6Hint) pack() ([]byte, error) <span class="cov0" title="0">{
        b := make([]byte, 0, 16*len(s.Hint))
        for _, e := range s.Hint </span><span class="cov0" title="0">{
                if len(e) != net.IPv6len || e.To4() != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("dns: delegipv6hint: expected ipv6, hint is ipv4")
                }</span>
                <span class="cov0" title="0">b = append(b, e...)</span>
        }
        <span class="cov0" title="0">return b, nil</span>
}

func (s *DELEGIPv6Hint) unpack(b []byte) error <span class="cov0" title="0">{
        if len(b) == 0 || len(b)%16 != 0 </span><span class="cov0" title="0">{
                return errors.New("dns: delegipv6hint: ipv6 address byte array length not a multiple of 16")
        }</span>
        <span class="cov0" title="0">b = cloneSlice(b)
        x := make([]net.IP, 0, len(b)/16)
        for i := 0; i &lt; len(b); i += 16 </span><span class="cov0" title="0">{
                ip := net.IP(b[i : i+16])
                if ip.To4() != nil </span><span class="cov0" title="0">{
                        return errors.New("dns: delegipv6hint: expected ipv6, got ipv4")
                }</span>
                <span class="cov0" title="0">x = append(x, ip)</span>
        }
        <span class="cov0" title="0">s.Hint = x
        return nil</span>
}

func (s *DELEGIPv6Hint) String() string <span class="cov0" title="0">{
        str := make([]string, len(s.Hint))
        for i, e := range s.Hint </span><span class="cov0" title="0">{
                if x := e.To4(); x != nil </span><span class="cov0" title="0">{
                        return "&lt;nil&gt;"
                }</span>
                <span class="cov0" title="0">str[i] = e.String()</span>
        }
        <span class="cov0" title="0">return strings.Join(str, ",")</span>
}

func (s *DELEGIPv6Hint) parse(b string) error <span class="cov0" title="0">{
        if b == "" </span><span class="cov0" title="0">{
                return errors.New("dns: delegipv6hint: empty hint")
        }</span>

        <span class="cov0" title="0">hint := make([]net.IP, 0, strings.Count(b, ",")+1)
        for len(b) &gt; 0 </span><span class="cov0" title="0">{
                var e string
                e, b, _ = strings.Cut(b, ",")
                ip := net.ParseIP(e)
                if ip == nil </span><span class="cov0" title="0">{
                        return errors.New("dns: delegipv6hint: bad ip")
                }</span>
                <span class="cov0" title="0">if ip.To4() != nil </span><span class="cov0" title="0">{
                        return errors.New("dns: delegipv6hint: expected ipv6, got ipv4-mapped-ipv6")
                }</span>
                <span class="cov0" title="0">hint = append(hint, ip)</span>
        }
        <span class="cov0" title="0">s.Hint = hint
        return nil</span>
}

func (s *DELEGIPv6Hint) copy() DELEGKeyValue <span class="cov0" title="0">{
        hint := make([]net.IP, len(s.Hint))
        for i, ip := range s.Hint </span><span class="cov0" title="0">{
                hint[i] = cloneSlice(ip)
        }</span>
        <span class="cov0" title="0">return &amp;DELEGIPv6Hint{Hint: hint}</span>
}

// SVCBDoHPath pair is used to indicate the URI template that the
// clients may use to construct a DNS over HTTPS URI.
//
// See RFC 9461 (https://datatracker.ietf.org/doc/html/rfc9461)
// and RFC 9462 (https://datatracker.ietf.org/doc/html/rfc9462).
//
// A basic example of using the dohpath option together with the alpn
// option to indicate support for DNS over HTTPS on a certain path:
//
//        s := new(dns.SVCB)
//        s.Hdr = dns.RR_Header{Name: ".", Rrtype: dns.TypeSVCB, Class: dns.ClassINET}
//        e := new(dns.SVCBAlpn)
//        e.Alpn = []string{"h2", "h3"}
//        p := new(dns.SVCBDoHPath)
//        p.Template = "/dns-query{?dns}"
//        s.Value = append(s.Value, e, p)
//
// The parsing currently doesn't validate that Template is a valid
// RFC 6570 URI template.
// type SVCBDoHPath struct {
//         Template string
// }

// func (*SVCBDoHPath) Key() SVCBKey            { return SVCB_DOHPATH }
// func (s *SVCBDoHPath) String() string        { return svcbParamToStr([]byte(s.Template)) }
// func (s *SVCBDoHPath) len() int              { return len(s.Template) }
// func (s *SVCBDoHPath) pack() ([]byte, error) { return []byte(s.Template), nil }

// func (s *SVCBDoHPath) unpack(b []byte) error {
//         s.Template = string(b)
//         return nil
// }

// func (s *SVCBDoHPath) parse(b string) error {
//         template, err := svcbParseParam(b)
//         if err != nil {
//                 return fmt.Errorf("dns: svcbdohpath: %w", err)
//         }
//         s.Template = string(template)
//         return nil
// }

// func (s *SVCBDoHPath) copy() SVCBKeyValue {
//         return &amp;SVCBDoHPath{
//                 Template: s.Template,
//         }
// }

// The "ohttp" SvcParamKey is used to indicate that a service described in a SVCB RR
// can be accessed as a target using an associated gateway.
// Both the presentation and wire-format values for the "ohttp" parameter MUST be empty.
//
// See RFC 9460 (https://datatracker.ietf.org/doc/html/rfc9460/)
// and RFC 9230 (https://datatracker.ietf.org/doc/html/rfc9230/)
//
// A basic example of using the dohpath option together with the alpn
// option to indicate support for DNS over HTTPS on a certain path:
//
//        s := new(dns.SVCB)
//        s.Hdr = dns.RR_Header{Name: ".", Rrtype: dns.TypeSVCB, Class: dns.ClassINET}
//        e := new(dns.SVCBAlpn)
//        e.Alpn = []string{"h2", "h3"}
//        p := new(dns.SVCBOhttp)
// s.Value = append(s.Value, e, p)
// type SVCBOhttp struct{}

// func (*SVCBOhttp) Key() SVCBKey          { return SVCB_OHTTP }
// func (*SVCBOhttp) copy() SVCBKeyValue    { return &amp;SVCBOhttp{} }
// func (*SVCBOhttp) pack() ([]byte, error) { return []byte{}, nil }
// func (*SVCBOhttp) String() string        { return "" }
// func (*SVCBOhttp) len() int              { return 0 }

// func (*SVCBOhttp) unpack(b []byte) error {
//         if len(b) != 0 {
//                 return errors.New("dns: svcbotthp: svcbotthp must have no value")
//         }
//         return nil
// }

// func (*SVCBOhttp) parse(b string) error {
//         if b != "" {
//                 return errors.New("dns: svcbotthp: svcbotthp must have no value")
//         }
//         return nil
// }

// SVCBLocal pair is intended for experimental/private use. The key is recommended
// to be in the range [SVCB_PRIVATE_LOWER, SVCB_PRIVATE_UPPER].
// Basic use pattern for creating a keyNNNNN option:
//
//        h := new(dns.HTTPS)
//        h.Hdr = dns.RR_Header{Name: ".", Rrtype: dns.TypeHTTPS, Class: dns.ClassINET}
//        e := new(dns.SVCBLocal)
//        e.KeyCode = 65400
//        e.Data = []byte("abc")
//        h.Value = append(h.Value, e)
type DELEGLocal struct {
        KeyCode DELEGKey // Never 65535 or any assigned keys.
        Data    []byte   // All byte sequences are allowed.
}

func (s *DELEGLocal) Key() DELEGKey         <span class="cov0" title="0">{ return s.KeyCode }</span>
func (s *DELEGLocal) String() string        <span class="cov0" title="0">{ return delegParamToStr(s.Data) }</span>
func (s *DELEGLocal) pack() ([]byte, error) <span class="cov0" title="0">{ return cloneSlice(s.Data), nil }</span>
func (s *DELEGLocal) len() int              <span class="cov0" title="0">{ return len(s.Data) }</span>

func (s *DELEGLocal) unpack(b []byte) error <span class="cov0" title="0">{
        s.Data = cloneSlice(b)
        return nil
}</span>

func (s *DELEGLocal) parse(b string) error <span class="cov0" title="0">{
        data, err := delegParseParam(b)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("dns: deleglocal: deleg private/experimental key %w", err)
        }</span>
        <span class="cov0" title="0">s.Data = data
        return nil</span>
}

func (s *DELEGLocal) copy() DELEGKeyValue <span class="cov0" title="0">{
        return &amp;DELEGLocal{s.KeyCode, cloneSlice(s.Data)}
}</span>

func (rr *DELEG) String() string <span class="cov8" title="1">{
        // s := rr.Hdr.String() +
        s := strconv.Itoa(int(rr.Priority)) + " " +
                sprintName(rr.Target)
        for _, e := range rr.Value </span><span class="cov0" title="0">{
                s += " " + e.Key().String() + "=\"" + e.String() + "\""
        }</span>
        <span class="cov8" title="1">return s</span>
}

// areSVCBPairArraysEqual checks if SVCBKeyValue arrays are equal after sorting their
// copies. arrA and arrB have equal lengths, otherwise zduplicate.go wouldn't call this function.
func areDELEGPairArraysEqual(a []DELEGKeyValue, b []DELEGKeyValue) bool <span class="cov0" title="0">{
        a = cloneSlice(a)
        b = cloneSlice(b)
        sort.Slice(a, func(i, j int) bool </span><span class="cov0" title="0">{ return a[i].Key() &lt; a[j].Key() }</span>)
        <span class="cov0" title="0">sort.Slice(b, func(i, j int) bool </span><span class="cov0" title="0">{ return b[i].Key() &lt; b[j].Key() }</span>)
        <span class="cov0" title="0">for i, e := range a </span><span class="cov0" title="0">{
                if e.Key() != b[i].Key() </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">b1, err1 := e.pack()
                b2, err2 := b[i].pack()
                if err1 != nil || err2 != nil || !bytes.Equal(b1, b2) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// svcbParamStr converts the value of an SVCB parameter into a DNS presentation-format string.
func delegParamToStr(s []byte) string <span class="cov0" title="0">{
        var str strings.Builder
        str.Grow(4 * len(s))
        for _, e := range s </span><span class="cov0" title="0">{
                if ' ' &lt;= e &amp;&amp; e &lt;= '~' </span><span class="cov0" title="0">{
                        switch e </span>{
                        case '"', ';', ' ', '\\':<span class="cov0" title="0">
                                str.WriteByte('\\')
                                str.WriteByte(e)</span>
                        default:<span class="cov0" title="0">
                                str.WriteByte(e)</span>
                        }
                } else<span class="cov0" title="0"> {
                        str.WriteString(escapeByte(e))
                }</span>
        }
        <span class="cov0" title="0">return str.String()</span>
}

// svcbParseParam parses a DNS presentation-format string into an SVCB parameter value.
func delegParseParam(b string) ([]byte, error) <span class="cov0" title="0">{
        data := make([]byte, 0, len(b))
        for i := 0; i &lt; len(b); </span><span class="cov0" title="0">{
                if b[i] != '\\' </span><span class="cov0" title="0">{
                        data = append(data, b[i])
                        i++
                        continue</span>
                }
                <span class="cov0" title="0">if i+1 == len(b) </span><span class="cov0" title="0">{
                        return nil, errors.New("escape unterminated")
                }</span>
                <span class="cov0" title="0">if isDigit(b[i+1]) </span><span class="cov0" title="0">{
                        if i+3 &lt; len(b) &amp;&amp; isDigit(b[i+2]) &amp;&amp; isDigit(b[i+3]) </span><span class="cov0" title="0">{
                                a, err := strconv.ParseUint(b[i+1:i+4], 10, 8)
                                if err == nil </span><span class="cov0" title="0">{
                                        i += 4
                                        data = append(data, byte(a))
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">return nil, errors.New("bad escaped octet")</span>
                } else<span class="cov0" title="0"> {
                        data = append(data, b[i+1])
                        i += 2
                }</span>
        }
        <span class="cov0" title="0">return data, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
 * Copyright (c) 2024 Johan Stenstam, johani@johani.org
 */

package core

import (
        "errors"
        "fmt"
        "strconv"

        "github.com/miekg/dns"
)

func init() <span class="cov8" title="1">{
        RegisterDsyncRR()
}</span>

// const TypeDSYNC = 0x0F9B

type DSYNC struct {
        Type   uint16
        Scheme DsyncScheme
        Port   uint16
        Target string
}

type DsyncScheme uint8

const (
        SchemeNotify  = 1
        SchemeUpdate  = 2
        SchemeScanner = 3
        SchemeAPI     = 4
        // Private schemes:
        SchemeMSUpdate = 129
        SchemeReport   = 130
)

var SchemeToString = map[DsyncScheme]string{
        SchemeNotify:  "NOTIFY",
        SchemeUpdate:  "UPDATE",
        SchemeScanner: "SCANNER",
        SchemeAPI:     "API",
        // Private schemes:
        SchemeMSUpdate: "MSUPDATE", // MSUPDATE is used in a multi-signer context and indicates a DNS UPDATE sent from a signer to the upstream unsigned zone.
        SchemeReport:   "REPORT",
}

var StringToScheme = map[string]DsyncScheme{
        "NOTIFY":   SchemeNotify,
        "UPDATE":   SchemeUpdate,
        "SCANNER":  SchemeScanner,
        "API":      SchemeAPI,
        "MSUPDATE": SchemeMSUpdate,
        "REPORT":   SchemeReport,
        "REPORTER": SchemeReport, // Keep this for backwards compatibility
        "1":        SchemeNotify,
        "2":        SchemeUpdate,
        "3":        SchemeScanner,
        "4":        SchemeAPI,
        // Private schemes:
        "129": SchemeMSUpdate,
        "130": SchemeReport,
}

func NewDSYNC() dns.PrivateRdata <span class="cov0" title="0">{ return new(DSYNC) }</span>

func (rd DSYNC) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s\t%s %d %s", dns.TypeToString[rd.Type], SchemeToString[rd.Scheme], rd.Port, rd.Target)
}</span>

func (rd *DSYNC) Parse(txt []string) error <span class="cov8" title="1">{
        if len(txt) != 4 </span><span class="cov0" title="0">{
                return errors.New("DSYNC requires a type, a scheme, a port and a target")
        }</span>
        <span class="cov8" title="1">t := dns.StringToType[txt[0]]
        if t == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid DSYNC type: %s", txt[0])
        }</span>

        <span class="cov8" title="1">scheme, exist := StringToScheme[txt[1]]
        if !exist </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid DSYNC scheme: %s", txt[1])
        }</span>

        <span class="cov8" title="1">port, err := strconv.Atoi(txt[2])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid DSYNC port: %s. Error: %v", txt[2], err)
        }</span>

        <span class="cov8" title="1">tgt := dns.Fqdn(txt[3])
        if _, ok := dns.IsDomainName(tgt); !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid DSYNC target: %s", txt[3])
        }</span>

        <span class="cov8" title="1">rd.Type = t
        rd.Scheme = DsyncScheme(scheme)
        rd.Port = uint16(port)
        rd.Target = tgt

        return nil</span>
}

func (rd *DSYNC) Pack(buf []byte) (int, error) <span class="cov0" title="0">{
        var off int
        off, err := packUint16(rd.Type, buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">off, err = packUint8(uint8(rd.Scheme), buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">off, err = packUint16(rd.Port, buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">off, err = dns.PackDomainName(rd.Target, buf, off, nil, false)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">return off, nil</span>
}

func (rd *DSYNC) Unpack(buf []byte) (int, error) <span class="cov0" title="0">{
        var off = 0
        var err error
        var tmp uint8

        rd.Type, off, err = unpackUint16(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">if off == len(buf) </span><span class="cov0" title="0">{
                return off, nil
        }</span>

        <span class="cov0" title="0">tmp, off, err = unpackUint8(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">rd.Scheme = DsyncScheme(tmp)
        if off == len(buf) </span><span class="cov0" title="0">{
                return off, nil
        }</span>

        <span class="cov0" title="0">rd.Port, off, err = unpackUint16(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">if off == len(buf) </span><span class="cov0" title="0">{
                return off, nil
        }</span>

        <span class="cov0" title="0">rd.Target, off, err = dns.UnpackDomainName(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">return off, nil</span>
}

func (rd *DSYNC) Copy(dest dns.PrivateRdata) error <span class="cov0" title="0">{
        cp := make([]byte, rd.Len())
        _, err := rd.Pack(cp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">d := dest.(*DSYNC)
        d.Type = rd.Type
        d.Scheme = rd.Scheme
        d.Port = rd.Port
        d.Target = rd.Target
        return nil</span>
}

func (rd *DSYNC) Len() int <span class="cov0" title="0">{
        return 1 + 2 + 2 + len(rd.Target) + 1 // add 1 for terminating 0
}</span>

func RegisterDsyncRR() error <span class="cov8" title="1">{
        dns.PrivateHandle("DSYNC", TypeDSYNC, NewDSYNC)
        // Explicitly set TypeToString to use "DSYNC" for printing
        dns.TypeToString[TypeDSYNC] = "DSYNC"
        return nil
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
 * Copyright (c) 2024 Johan Stenstam, johani@johani.org
 */

package core

import (
        "errors"
        "fmt"

        "github.com/miekg/dns"
)

// example.com. IN MSIGNER ON API multisigner.provider.com.
// example.com. IN MSIGNER OFF 53 ms-conductor.signerco.net.

func init() <span class="cov8" title="1">{
        RegisterHsyncRR()
}</span>

//const TypeHSYNC = 0x0F9D

type HSYNC struct {
        State    uint8 // 0=OFF, 1=ON
        NSmgmt   uint8 // 1=OWNER, 2=AGENT
        Sign     uint8 // 1=SIGN, 2=NOSIGN
        Identity string
        Upstream string
}

const (
        HsyncStateON     uint8 = 1
        HsyncStateOFF    uint8 = 0
        HsyncNSmgmtOWNER uint8 = 1
        HsyncNSmgmtAGENT uint8 = 2
        HsyncSignYES     uint8 = 1
        HsyncSignNO      uint8 = 0
)

var HsyncStateToString = map[uint8]string{
        HsyncStateON:  "ON",
        HsyncStateOFF: "OFF",
}

var StringToHsyncState = map[string]uint8{
        "ON":  HsyncStateON,
        "OFF": HsyncStateOFF,
}

var HsyncNSmgmtToString = map[uint8]string{
        HsyncNSmgmtOWNER: "OWNER",
        HsyncNSmgmtAGENT: "AGENT",
}

var StringToHsyncNSmgmt = map[string]uint8{
        "OWNER": HsyncNSmgmtOWNER,
        "AGENT": HsyncNSmgmtAGENT,
}

var HsyncSignToString = map[uint8]string{
        HsyncSignYES: "SIGN",
        HsyncSignNO:  "NOSIGN",
}

var StringToHsyncSign = map[string]uint8{
        "SIGN":   HsyncSignYES,
        "NOSIGN": HsyncSignNO,
}

func NewHSYNC() dns.PrivateRdata <span class="cov0" title="0">{ return new(HSYNC) }</span>

func (rd HSYNC) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%-3s  %-3s  %-3s  %s %s", HsyncStateToString[rd.State], HsyncNSmgmtToString[rd.NSmgmt], HsyncSignToString[rd.Sign], rd.Identity, rd.Upstream)
}</span>

func (rd *HSYNC) Parse(txt []string) error <span class="cov8" title="1">{
        // log.Printf("parsing HSYNC: %v", txt)
        if len(txt) != 5 </span><span class="cov0" title="0">{
                return errors.New("HSYNC requires values for State, NSmgmt and Sign plus identity and upstream domain names")
        }</span>
        <span class="cov8" title="1">state, exist := StringToHsyncState[txt[0]]
        if !exist </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid HSYNC type: %s", txt[0])
        }</span>

        <span class="cov8" title="1">nsmgmt, exist := StringToHsyncNSmgmt[txt[1]]
        if !exist </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid HSYNC NSmgmt value: %s", txt[1])
        }</span>

        <span class="cov8" title="1">sign, exist := StringToHsyncSign[txt[2]]
        if !exist </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid HSYNC Sign value: %s", txt[2])
        }</span>

        <span class="cov8" title="1">id := dns.Fqdn(txt[3])
        if _, ok := dns.IsDomainName(id); !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid HSYNC identity: %s", txt[3])
        }</span>

        <span class="cov8" title="1">upstream := dns.Fqdn(txt[4])
        if _, ok := dns.IsDomainName(upstream); !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid HSYNC upstream: %s", txt[4])
        }</span>

        <span class="cov8" title="1">rd.State = state
        rd.NSmgmt = nsmgmt
        rd.Sign = sign
        rd.Identity = id
        rd.Upstream = upstream
        return nil</span>
}

func (rd *HSYNC) Pack(buf []byte) (int, error) <span class="cov0" title="0">{
        var off int
        off, err := packUint8(rd.State, buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">off, err = packUint8(uint8(rd.NSmgmt), buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">off, err = packUint8(uint8(rd.Sign), buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">off, err = dns.PackDomainName(rd.Identity, buf, off, nil, false)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">off, err = dns.PackDomainName(rd.Upstream, buf, off, nil, false)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">return off, nil</span>
}

func (rd *HSYNC) Unpack(buf []byte) (int, error) <span class="cov0" title="0">{
        var off = 0
        var err error

        rd.State, off, err = unpackUint8(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">if off == len(buf) </span><span class="cov0" title="0">{
                return off, nil
        }</span>

        <span class="cov0" title="0">rd.NSmgmt, off, err = unpackUint8(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">if off == len(buf) </span><span class="cov0" title="0">{
                return off, nil
        }</span>

        <span class="cov0" title="0">rd.Sign, off, err = unpackUint8(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">if off == len(buf) </span><span class="cov0" title="0">{
                return off, nil
        }</span>

        <span class="cov0" title="0">rd.Identity, off, err = dns.UnpackDomainName(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">rd.Upstream, off, err = dns.UnpackDomainName(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">return off, nil</span>
}

func (rd *HSYNC) Copy(dest dns.PrivateRdata) error <span class="cov0" title="0">{
        cp := make([]byte, rd.Len())
        _, err := rd.Pack(cp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">d := dest.(*HSYNC)
        d.State = rd.State
        d.NSmgmt = rd.NSmgmt
        d.Sign = rd.Sign
        d.Identity = rd.Identity
        d.Upstream = rd.Upstream
        return nil</span>
}

func (rd *HSYNC) Len() int <span class="cov0" title="0">{
        return 1 + 1 + 1 + len(rd.Identity) + len(rd.Upstream) + 2 // +2 for two terminating zeros
}</span>

func RegisterHsyncRR() error <span class="cov8" title="1">{
        dns.PrivateHandle("HSYNC", TypeHSYNC, NewHSYNC)
        // Explicitly set TypeToString to use "HSYNC" for printing
        dns.TypeToString[TypeHSYNC] = "HSYNC"
        // log.Printf("Registered HSYNC RR")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
 * Copyright (c) 2024 Johan Stenstam, johani@johani.org
 */

package core

import (
        "errors"
        "fmt"
        "strings"

        "github.com/miekg/dns"
)

// example.com. IN MSIGNER ON API multisigner.provider.com.
// example.com. IN MSIGNER OFF 53 ms-conductor.signerco.net.

func init() <span class="cov8" title="1">{
        RegisterHsync2RR()
}</span>

//const TypeHSYNC = 0x0F9D

type HSYNC2 struct {
        State    uint8  // 0=OFF, 1=ON
        Flags    uint16 // Will hold both NSmgmt and Sign bits
        Identity string
        Upstream string
}

// Define bit positions and masks in the Flags field
const (
        // Single bit flags
        FlagNSmgmt uint16 = 1 &lt;&lt; 0 // bit 0: 0=OWNER, 1=AGENT
        FlagSign   uint16 = 1 &lt;&lt; 1 // bit 1: 0=NOSIGN, 1=SIGN
        FlagAudit  uint16 = 1 &lt;&lt; 2 // bit 2: 0=NO, 1=YES

        // Multi-bit fields
        ParentSyncMask  uint16 = 0x7 &lt;&lt; 3 // bits 3-5: 3 bits for parentsync
        ParentSyncShift uint   = 3        // shift amount for parentsync field
)

// ParentSync values (using iota for sequential values)
const (
        ParentSyncOwner uint16 = iota
        ParentSyncNotify
        ParentSyncUpdate
        ParentSyncAPI
        // room for 4 more values
)

// Keep these constants for State
const (
        Hsync2StateON  uint8 = 1
        Hsync2StateOFF uint8 = 0
)

// Keep the State mappings
var Hsync2StateToString = map[uint8]string{
        Hsync2StateON:  "ON",
        Hsync2StateOFF: "OFF",
}

var StringToHsync2State = map[string]uint8{
        "ON":  Hsync2StateON,
        "OFF": Hsync2StateOFF,
}

func NewHSYNC2() dns.PrivateRdata <span class="cov0" title="0">{ return new(HSYNC2) }</span>

func (rd HSYNC2) String() string <span class="cov8" title="1">{
        // Build the flags string
        flags := make([]string, 0, 4) // increased capacity for new flags

        // Add nsmgmt flag
        if rd.IsAgent() </span><span class="cov8" title="1">{
                flags = append(flags, "nsmgmt=agent")
        }</span> else<span class="cov0" title="0"> {
                flags = append(flags, "nsmgmt=owner")
        }</span>

        // Add sign flag
        <span class="cov8" title="1">if rd.DoSign() </span><span class="cov8" title="1">{
                flags = append(flags, "sign=yes")
        }</span> else<span class="cov0" title="0"> {
                flags = append(flags, "sign=no")
        }</span>

        // Add audit flag
        <span class="cov8" title="1">if rd.DoAudit() </span><span class="cov0" title="0">{
                flags = append(flags, "audit=yes")
        }</span> else<span class="cov8" title="1"> {
                flags = append(flags, "audit=no")
        }</span>

        // Add parentsync flag
        <span class="cov8" title="1">if psStr, ok := parentSyncToString[rd.GetParentSync()]; ok </span><span class="cov8" title="1">{
                flags = append(flags, "parentsync="+psStr)
        }</span> else<span class="cov0" title="0"> {
                flags = append(flags, "parentsync=unknown")
        }</span>

        // Combine flags with semicolons
        <span class="cov8" title="1">flagStr := strings.Join(flags, "; ")

        return fmt.Sprintf("%s \"%s\" %s %s",
                Hsync2StateToString[rd.State],
                flagStr,
                rd.Identity,
                rd.Upstream)</span>
}

func (rd *HSYNC2) Parse(txt []string) error <span class="cov8" title="1">{
        if len(txt) != 4 </span><span class="cov0" title="0">{
                return errors.New("HSYNC2 requires: State, flags-string, identity and upstream domain names")
        }</span>

        // Parse State
        <span class="cov8" title="1">state, exist := StringToHsync2State[strings.ToUpper(txt[0])]
        if !exist </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid HSYNC2 state: %s", txt[0])
        }</span>
        <span class="cov8" title="1">rd.State = state

        // Parse flags string - remove quotes and split on semicolons
        flagsStr := strings.Trim(txt[1], "\"")
        flagPairs := strings.Split(flagsStr, ";")

        // Initialize flags
        rd.Flags = 0

        // Track which flags we've seen
        seenFlags := map[string]bool{
                "nsmgmt":     false,
                "sign":       false,
                "audit":      false,
                "parentsync": false,
        }

        // Process each flag
        for _, pair := range flagPairs </span><span class="cov8" title="1">{
                pair = strings.TrimSpace(pair)
                kv := strings.Split(pair, "=")
                if len(kv) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid flag format: %s", pair)
                }</span>

                <span class="cov8" title="1">key := strings.ToLower(strings.TrimSpace(kv[0]))
                value := strings.ToLower(strings.TrimSpace(kv[1]))

                // Mark this flag as seen
                seenFlags[key] = true

                switch key </span>{
                case "nsmgmt":<span class="cov8" title="1">
                        switch value </span>{
                        case "owner":<span class="cov0" title="0">
                                rd.SetNSmgmt(false)</span>
                        case "agent":<span class="cov8" title="1">
                                rd.SetNSmgmt(true)</span>
                        default:<span class="cov0" title="0">
                                return fmt.Errorf("invalid nsmgmt value: %s", value)</span>
                        }
                case "sign":<span class="cov8" title="1">
                        switch value </span>{
                        case "yes":<span class="cov8" title="1">
                                rd.SetSign(true)</span>
                        case "no":<span class="cov0" title="0">
                                rd.SetSign(false)</span>
                        default:<span class="cov0" title="0">
                                return fmt.Errorf("invalid sign value: %s", value)</span>
                        }
                case "audit":<span class="cov8" title="1">
                        switch value </span>{
                        case "yes":<span class="cov0" title="0">
                                rd.SetAudit(true)</span>
                        case "no":<span class="cov8" title="1">
                                rd.SetAudit(false)</span>
                        default:<span class="cov0" title="0">
                                return fmt.Errorf("invalid audit value: %s", value)</span>
                        }
                case "parentsync":<span class="cov8" title="1">
                        if psValue, ok := stringToParentSync[value]; ok </span><span class="cov8" title="1">{
                                if err := rd.SetParentSync(psValue); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return fmt.Errorf("invalid parentsync value: %s", value)
                        }</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unknown flag: %s", key)</span>
                }
        }

        // Check that all required flags were present
        <span class="cov8" title="1">for flag, seen := range seenFlags </span><span class="cov8" title="1">{
                if !seen </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing required flag: %s", flag)
                }</span>
        }

        // Parse Identity
        <span class="cov8" title="1">id := dns.Fqdn(txt[2])
        if _, ok := dns.IsDomainName(id); !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid HSYNC2 identity: %s", txt[2])
        }</span>
        <span class="cov8" title="1">rd.Identity = id

        // Parse Upstream
        upstream := dns.Fqdn(txt[3])
        if _, ok := dns.IsDomainName(upstream); !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid HSYNC2 upstream: %s", txt[3])
        }</span>
        <span class="cov8" title="1">rd.Upstream = upstream

        return nil</span>
}

func (rd *HSYNC2) Pack(buf []byte) (int, error) <span class="cov0" title="0">{
        var off int
        off, err := packUint8(rd.State, buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">off, err = packUint16(rd.Flags, buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">off, err = dns.PackDomainName(rd.Identity, buf, off, nil, false)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">off, err = dns.PackDomainName(rd.Upstream, buf, off, nil, false)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">return off, nil</span>
}

func (rd *HSYNC2) Unpack(buf []byte) (int, error) <span class="cov0" title="0">{
        var off = 0
        var err error

        rd.State, off, err = unpackUint8(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">if off == len(buf) </span><span class="cov0" title="0">{
                return off, nil
        }</span>

        <span class="cov0" title="0">rd.Flags, off, err = unpackUint16(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">if off == len(buf) </span><span class="cov0" title="0">{
                return off, nil
        }</span>

        <span class="cov0" title="0">rd.Identity, off, err = dns.UnpackDomainName(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">rd.Upstream, off, err = dns.UnpackDomainName(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">return off, nil</span>
}

func (rd *HSYNC2) Copy(dest dns.PrivateRdata) error <span class="cov0" title="0">{
        cp := make([]byte, rd.Len())
        _, err := rd.Pack(cp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">d := dest.(*HSYNC2)
        d.State = rd.State
        d.Flags = rd.Flags
        d.Identity = rd.Identity
        d.Upstream = rd.Upstream
        return nil</span>
}

func (rd *HSYNC2) Len() int <span class="cov0" title="0">{
        return 1 + 2 + len(rd.Identity) + len(rd.Upstream) + 2 // +2 for two terminating zeros
}</span>

func RegisterHsync2RR() error <span class="cov8" title="1">{
        dns.PrivateHandle("HSYNC2", TypeHSYNC2, NewHSYNC2)
        // Explicitly set TypeToString to use "HSYNC2" for printing
        dns.TypeToString[TypeHSYNC2] = "HSYNC2"
        // log.Printf("Registered HSYNC RR")
        return nil
}</span>

// Helper functions for flag handling
func (rd *HSYNC2) SetNSmgmt(isAgent bool) <span class="cov8" title="1">{
        if isAgent </span><span class="cov8" title="1">{
                rd.Flags |= FlagNSmgmt
        }</span> else<span class="cov0" title="0"> {
                rd.Flags &amp;^= FlagNSmgmt
        }</span>
}

func (rd *HSYNC2) SetSign(doSign bool) <span class="cov8" title="1">{
        if doSign </span><span class="cov8" title="1">{
                rd.Flags |= FlagSign
        }</span> else<span class="cov0" title="0"> {
                rd.Flags &amp;^= FlagSign
        }</span>
}

func (rd *HSYNC2) IsAgent() bool <span class="cov8" title="1">{
        return (rd.Flags &amp; FlagNSmgmt) != 0
}</span>

func (rd *HSYNC2) DoSign() bool <span class="cov8" title="1">{
        return (rd.Flags &amp; FlagSign) != 0
}</span>

// Add helper functions for the new flags
func (rd *HSYNC2) SetAudit(enabled bool) <span class="cov8" title="1">{
        if enabled </span><span class="cov0" title="0">{
                rd.Flags |= FlagAudit
        }</span> else<span class="cov8" title="1"> {
                rd.Flags &amp;^= FlagAudit
        }</span>
}

func (rd *HSYNC2) DoAudit() bool <span class="cov8" title="1">{
        return (rd.Flags &amp; FlagAudit) != 0
}</span>

func (rd *HSYNC2) SetParentSync(value uint16) error <span class="cov8" title="1">{
        if value &gt;= 8 </span><span class="cov0" title="0">{ // 3 bits = 8 values
                return fmt.Errorf("invalid parentsync value: %d", value)
        }</span>
        // Clear the field
        <span class="cov8" title="1">rd.Flags &amp;^= ParentSyncMask
        // Set the new value
        rd.Flags |= (value &lt;&lt; ParentSyncShift) &amp; ParentSyncMask
        return nil</span>
}

func (rd *HSYNC2) GetParentSync() uint16 <span class="cov8" title="1">{
        return (rd.Flags &amp; ParentSyncMask) &gt;&gt; ParentSyncShift
}</span>

// Helper for parentsync string conversion
var parentSyncToString = map[uint16]string{
        ParentSyncOwner:  "owner",
        ParentSyncNotify: "notify",
        ParentSyncUpdate: "update",
        ParentSyncAPI:    "api",
}

var stringToParentSync = map[string]uint16{
        "owner":  ParentSyncOwner,
        "notify": ParentSyncNotify,
        "update": ParentSyncUpdate,
        "api":    ParentSyncAPI,
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
 * Copyright (c) 2025 Johan Stenstam, johani@johani.org
 */

package core

import (
        "encoding/base64"
        "encoding/binary"
        "errors"
        "fmt"
        "strconv"

        "github.com/miekg/dns"
)

func init() <span class="cov8" title="1">{
        RegisterCHUNKRR()
}</span>

// CHUNK - Chunked Data Transport (generalized from JSONCHUNK)
// Transports large format-specific data (zone lists or encrypted blobs) in chunks
// The format is determined by the associated MANIFEST, not by CHUNK itself.
//
// RDATA structure:
//   - Sequence (uint16): Chunk sequence number (0-based)
//   - Total (uint16): Total number of chunks
//   - Data length (uint16): Length of format-specific data
//   - Data ([]byte): Format-specific data
//
// For FormatJSON (as specified in MANIFEST), the data is base64-encoded JSON data (raw bytes, not base64 string)
//
// Presentation format (space-separated values):
//   - Single chunk: &lt;base64-data&gt;
//     Example: "&lt;base64-encoded-chunk-data&gt;"
//   - Multiple chunks: &lt;base64-data&gt; &lt;sequence&gt; &lt;total&gt;
//     Example: "&lt;base64-encoded-chunk-data&gt; 1 2"
type CHUNK struct {
        Sequence uint16 `json:"sequence"` // Chunk sequence number (0-based)
        Total    uint16 `json:"total"`    // Total number of chunks
        Data     []byte `json:"data"`     // Format-specific data (format determined by associated MANIFEST)
}

func NewCHUNK() dns.PrivateRdata <span class="cov0" title="0">{ return new(CHUNK) }</span>

func (rd CHUNK) String() string <span class="cov8" title="1">{
        dataStr := base64.StdEncoding.EncodeToString(rd.Data)
        if rd.Total &gt; 1 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s %d %d", dataStr, rd.Sequence, rd.Total)
        }</span>
        <span class="cov0" title="0">return dataStr</span>
}

func (rd *CHUNK) Parse(txt []string) error <span class="cov8" title="1">{
        if len(txt) &lt; 1 || len(txt) &gt; 3 </span><span class="cov0" title="0">{
                return errors.New("CHUNK requires base64 data and optionally sequence/total")
        }</span>

        // Decode base64-encoded data
        <span class="cov8" title="1">data, err := base64.StdEncoding.DecodeString(txt[0])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid CHUNK base64 data: %v", err)
        }</span>

        <span class="cov8" title="1">rd.Data = data
        rd.Sequence = 0
        rd.Total = 1

        // Parse sequence and total if present
        if len(txt) &gt;= 3 </span><span class="cov8" title="1">{
                seq, err := strconv.ParseUint(txt[1], 10, 16)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid CHUNK sequence: %s", txt[1])
                }</span>
                <span class="cov8" title="1">total, err := strconv.ParseUint(txt[2], 10, 16)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid CHUNK total: %s", txt[2])
                }</span>
                <span class="cov8" title="1">rd.Sequence = uint16(seq)
                rd.Total = uint16(total)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (rd *CHUNK) Pack(buf []byte) (int, error) <span class="cov0" title="0">{
        off := 0

        // Pack sequence and total (uint16 each)
        if len(buf) &lt; off+4 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too small for CHUNK sequence/total")
        }</span>
        <span class="cov0" title="0">buf[off] = byte(rd.Sequence &gt;&gt; 8)
        buf[off+1] = byte(rd.Sequence)
        off += 2
        buf[off] = byte(rd.Total &gt;&gt; 8)
        buf[off+1] = byte(rd.Total)
        off += 2

        // Pack data length (uint16)
        dataLen := len(rd.Data)
        if dataLen &gt; 65535 </span><span class="cov0" title="0">{
                return off, errors.New("CHUNK data too long")
        }</span>
        <span class="cov0" title="0">if len(buf) &lt; off+2 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too small for CHUNK data length")
        }</span>
        <span class="cov0" title="0">buf[off] = byte(dataLen &gt;&gt; 8)
        buf[off+1] = byte(dataLen)
        off += 2

        // Pack data
        if len(buf) &lt; off+dataLen </span><span class="cov0" title="0">{
                return off, errors.New("buffer too small for CHUNK data")
        }</span>
        <span class="cov0" title="0">copy(buf[off:], rd.Data)
        off += dataLen

        return off, nil</span>
}

func (rd *CHUNK) Unpack(buf []byte) (int, error) <span class="cov0" title="0">{
        off := 0

        // Unpack sequence
        if len(buf) &lt; off+2 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too short for CHUNK sequence")
        }</span>
        <span class="cov0" title="0">rd.Sequence = binary.BigEndian.Uint16(buf[off:])
        off += 2

        // Unpack total
        if len(buf) &lt; off+2 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too short for CHUNK total")
        }</span>
        <span class="cov0" title="0">rd.Total = binary.BigEndian.Uint16(buf[off:])
        off += 2

        // Unpack data length
        if len(buf) &lt; off+2 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too short for CHUNK data length")
        }</span>
        <span class="cov0" title="0">dataLen := int(binary.BigEndian.Uint16(buf[off:]))
        off += 2

        // Unpack data
        if len(buf) &lt; off+dataLen </span><span class="cov0" title="0">{
                return off, errors.New("buffer too short for CHUNK data")
        }</span>
        <span class="cov0" title="0">rd.Data = make([]byte, dataLen)
        copy(rd.Data, buf[off:off+dataLen])
        off += dataLen

        return off, nil</span>
}

func (rd *CHUNK) Copy(dest dns.PrivateRdata) error <span class="cov0" title="0">{
        d := dest.(*CHUNK)
        d.Sequence = rd.Sequence
        d.Total = rd.Total
        if rd.Data != nil </span><span class="cov0" title="0">{
                d.Data = make([]byte, len(rd.Data))
                copy(d.Data, rd.Data)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (rd *CHUNK) Len() int <span class="cov0" title="0">{
        return 2 + // sequence
                2 + // total
                2 + // data length
                len(rd.Data) // data
}</span>

func RegisterCHUNKRR() error <span class="cov8" title="1">{
        dns.PrivateHandle("CHUNK", TypeCHUNK, NewCHUNK)
        // Explicitly set TypeToString to use "CHUNK" for printing
        dns.TypeToString[TypeCHUNK] = "CHUNK"
        return nil
}</span>

</pre>
		
		<pre class="file" id="file10" style="display: none">/*
 * Copyright (c) 2025 Johan Stenstam, johani@johani.org
 */

package core

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "strconv"
        "strings"

        "github.com/miekg/dns"
)

func init() <span class="cov8" title="1">{
        RegisterMANIFESTRR()
}</span>

// MANIFEST - Distribution Manifest (generalized from JSONMANIFEST)
// Small metadata about a distribution event for a specific node
// Format: Format byte + HMAC + format-specific data structure
// Size limit: &lt;500 bytes (never chunked)
//
// RDATA structure:
//   - Format (uint8): Format identifier (FormatJSON = 1, etc.)
//   - HMAC length (uint16): Length of HMAC checksum
//   - HMAC ([]byte): HMAC-SHA256 checksum of the manifest (excluding HMAC field)
//   - Format-specific data: For FormatJSON, this is a JSON structure
//
// For FormatJSON, the JSON structure contains:
//   - chunk_count: Number of CHUNK records (0 if payload is inline)
//   - chunk_size: Maximum size of each chunk in bytes (optional)
//   - metadata: Additional metadata (must include "content" field)
//   - payload: Inline payload (base64-encoded in JSON, optional)
//
// The Metadata map should contain a "content" field indicating the type:
//   - "zonelist": List of zone names (JSON array of strings)
//   - "encrypted_keys": HPKE-encrypted key material
//   - "clear_text": Clear text payload (base64 encoded)
//   - "encrypted_text": HPKE-encrypted text payload (base64 encoded)
//
// When payload fits inline (typically &lt; 1000 bytes), it can be included directly
// in the Payload field, eliminating the need for separate CHUNK queries.
// In this case, ChunkCount should be 0 (or Payload is used instead of chunks).
//
// Presentation format (space-separated values):
//   &lt;format&gt; &lt;hmac&gt; &lt;json-data&gt;
//   Example:
//   node.distid.control. IN MANIFEST 1 a889a20e0722d903fe0772226ddd21bce465056f94785ea3dbba74069c897092 {"chunk_count":1,"chunk_size":60000,"metadata":{"content":"encrypted_keys","distribution_id":"3a29c33a",...}, "payload":"&lt;base64-encoded-payload&gt;"}"
type MANIFEST struct {
        Format     uint8                  // Format identifier (FormatJSON = 1, etc.) - REQUIRED
        HMAC       []byte                 // HMAC-SHA256 checksum - REQUIRED (replaces old Checksum field)
        ChunkCount uint16                 `json:"chunk_count"`        // Number of CHUNK records (0 if payload is inline)
        ChunkSize  uint16                 `json:"chunk_size,omitempty"` // Maximum size of each chunk in bytes (optional)
        Metadata   map[string]interface{} `json:"metadata,omitempty"` // Additional metadata (must include "content")
        Payload    []byte                 `json:"payload,omitempty"`  // Inline payload (base64-encoded in JSON, optional)
}

func NewMANIFEST() dns.PrivateRdata <span class="cov0" title="0">{ return new(MANIFEST) }</span>

func (rd MANIFEST) String() string <span class="cov8" title="1">{
        // Format field
        formatStr := FormatToString[rd.Format]
        if formatStr == "" </span><span class="cov0" title="0">{
                formatStr = fmt.Sprintf("FORMAT%d", rd.Format)
        }</span>
        
        // HMAC field
        <span class="cov8" title="1">hmacStr := fmt.Sprintf("%x", rd.HMAC)
        
        // Data field: marshal JSON fields
        jsonFields := struct {
                ChunkCount uint16                 `json:"chunk_count"`
                ChunkSize  uint16                 `json:"chunk_size,omitempty"`
                Metadata   map[string]interface{} `json:"metadata,omitempty"`
                Payload    []byte                 `json:"payload,omitempty"`
        }{
                ChunkCount: rd.ChunkCount,
                ChunkSize:  rd.ChunkSize,
                Metadata:   rd.Metadata,
                Payload:    rd.Payload,
        }
        jsonBytes, err := json.Marshal(jsonFields)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s %s marshal_error=%v", formatStr, hmacStr, err)
        }</span>
        
        // Order: Format HMAC Data (MANIFEST has no Sequence/Total fields)
        <span class="cov8" title="1">return fmt.Sprintf("%s %s %s", formatStr, hmacStr, string(jsonBytes))</span>
}

func (rd *MANIFEST) Parse(txt []string) error <span class="cov8" title="1">{
        // MANIFEST String() format: "Format HMAC JSON-data"
        // Format: "JSON" or "FORMAT&lt;n&gt;"
        // HMAC: hex string
        // JSON-data: the JSON structure
        
        if len(txt) &lt; 3 </span><span class="cov0" title="0">{
                // Fallback: try to parse as single JSON string (backward compatibility)
                if len(txt) == 1 </span><span class="cov0" title="0">{
                        if err := json.Unmarshal([]byte(txt[0]), rd); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid MANIFEST JSON: %v", err)
                        }</span>
                        // Validate Format is present and valid
                        <span class="cov0" title="0">if rd.Format == 0 </span><span class="cov0" title="0">{
                                return errors.New("MANIFEST format field is required")
                        }</span>
                        <span class="cov0" title="0">if rd.Format != FormatJSON </span><span class="cov0" title="0">{
                                return fmt.Errorf("MANIFEST format %d not supported (only FormatJSON=1 is currently supported)", rd.Format)
                        }</span>
                        // HMAC validation
                        <span class="cov0" title="0">if rd.HMAC != nil &amp;&amp; len(rd.HMAC) != 32 </span><span class="cov0" title="0">{
                                return fmt.Errorf("MANIFEST HMAC must be 32 bytes (SHA-256), got %d bytes", len(rd.HMAC))
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">return errors.New("MANIFEST requires 3 fields: Format HMAC JSON-data")</span>
        }

        // Parse Format (string -&gt; enum)
        <span class="cov8" title="1">formatStr := txt[0]
        if format, ok := StringToFormat[formatStr]; ok </span><span class="cov8" title="1">{
                rd.Format = format
        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(formatStr, "FORMAT") </span><span class="cov0" title="0">{
                // Format like "FORMAT1" (fallback for unknown formats)
                formatNum, err := strconv.ParseUint(strings.TrimPrefix(formatStr, "FORMAT"), 10, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid MANIFEST format: %s", formatStr)
                }</span>
                <span class="cov0" title="0">rd.Format = uint8(formatNum)</span>
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("invalid MANIFEST format: %s", formatStr)
        }</span>

        // Parse HMAC (hex string)
        <span class="cov8" title="1">hmacStr := txt[1]
        hmac, err := hex.DecodeString(hmacStr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid MANIFEST HMAC (hex): %s", hmacStr)
        }</span>
        <span class="cov8" title="1">if len(hmac) != 32 </span><span class="cov0" title="0">{
                return fmt.Errorf("MANIFEST HMAC must be 32 bytes (SHA-256), got %d bytes", len(hmac))
        }</span>
        <span class="cov8" title="1">rd.HMAC = hmac

        // Parse JSON data (may contain spaces, so join remaining tokens)
        jsonStr := strings.Join(txt[2:], " ")
        var jsonFields struct {
                ChunkCount uint16                 `json:"chunk_count"`
                ChunkSize  uint16                 `json:"chunk_size,omitempty"`
                Metadata   map[string]interface{} `json:"metadata,omitempty"`
                Payload    []byte                 `json:"payload,omitempty"`
        }
        if err := json.Unmarshal([]byte(jsonStr), &amp;jsonFields); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid MANIFEST JSON: %v", err)
        }</span>
        <span class="cov8" title="1">rd.ChunkCount = jsonFields.ChunkCount
        rd.ChunkSize = jsonFields.ChunkSize
        rd.Metadata = jsonFields.Metadata
        rd.Payload = jsonFields.Payload

        return nil</span>
}

func (rd *MANIFEST) Pack(buf []byte) (int, error) <span class="cov0" title="0">{
        // Validate Format is set
        if rd.Format == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("MANIFEST format field is required")
        }</span>

        // Pack Format (uint8) - first byte
        <span class="cov0" title="0">off := 0
        if len(buf) &lt; off+1 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too small for MANIFEST format")
        }</span>
        <span class="cov0" title="0">buf[off] = rd.Format
        off += 1

        // Pack HMAC length (uint16) + HMAC data
        if rd.HMAC == nil </span><span class="cov0" title="0">{
                return 0, errors.New("MANIFEST HMAC is required")
        }</span>
        <span class="cov0" title="0">hmacLen := len(rd.HMAC)
        if hmacLen &gt; 65535 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("MANIFEST HMAC too long (max 65535 bytes, got %d)", hmacLen)
        }</span>
        <span class="cov0" title="0">if len(buf) &lt; off+2 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too small for MANIFEST HMAC length")
        }</span>
        <span class="cov0" title="0">buf[off] = byte(hmacLen &gt;&gt; 8)
        buf[off+1] = byte(hmacLen)
        off += 2

        if len(buf) &lt; off+hmacLen </span><span class="cov0" title="0">{
                return off, errors.New("buffer too small for MANIFEST HMAC")
        }</span>
        <span class="cov0" title="0">copy(buf[off:], rd.HMAC)
        off += hmacLen

        // Pack format-specific data (for FormatJSON, this is JSON)
        // Marshal only the JSON fields (not Format or HMAC)
        jsonFields := struct {
                ChunkCount uint16                 `json:"chunk_count"`
                ChunkSize  uint16                 `json:"chunk_size,omitempty"`
                Metadata   map[string]interface{} `json:"metadata,omitempty"`
                Payload    []byte                 `json:"payload,omitempty"`
        }{
                ChunkCount: rd.ChunkCount,
                ChunkSize:  rd.ChunkSize,
                Metadata:   rd.Metadata,
                Payload:    rd.Payload,
        }
        jsonBytes, err := json.Marshal(jsonFields)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to marshal MANIFEST JSON: %v", err)
        }</span>

        <span class="cov0" title="0">if len(jsonBytes) &gt; 65535 </span><span class="cov0" title="0">{
                return 0, errors.New("MANIFEST JSON data too large (max 65535 bytes)")
        }</span>

        // Pack JSON data length (uint16) + JSON data
        <span class="cov0" title="0">if len(buf) &lt; off+2 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too small for MANIFEST JSON length")
        }</span>
        <span class="cov0" title="0">buf[off] = byte(len(jsonBytes) &gt;&gt; 8)
        buf[off+1] = byte(len(jsonBytes))
        off += 2

        if len(buf) &lt; off+len(jsonBytes) </span><span class="cov0" title="0">{
                return off, errors.New("buffer too small for MANIFEST JSON data")
        }</span>
        <span class="cov0" title="0">copy(buf[off:], jsonBytes)
        off += len(jsonBytes)

        return off, nil</span>
}

func (rd *MANIFEST) Unpack(buf []byte) (int, error) <span class="cov0" title="0">{
        off := 0

        // Unpack Format (uint8)
        if len(buf) &lt; off+1 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too short for MANIFEST format")
        }</span>
        <span class="cov0" title="0">rd.Format = buf[off]
        off += 1

        // Validate Format
        if rd.Format == 0 </span><span class="cov0" title="0">{
                return off, errors.New("MANIFEST format field is required (cannot be 0)")
        }</span>
        <span class="cov0" title="0">if rd.Format != FormatJSON </span><span class="cov0" title="0">{
                return off, fmt.Errorf("MANIFEST format %d not supported (only FormatJSON=1 is currently supported)", rd.Format)
        }</span>

        // Unpack HMAC length (uint16) + HMAC data
        <span class="cov0" title="0">if len(buf) &lt; off+2 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too short for MANIFEST HMAC length")
        }</span>
        <span class="cov0" title="0">hmacLen := int(buf[off])&lt;&lt;8 | int(buf[off+1])
        off += 2

        if hmacLen == 0 </span><span class="cov0" title="0">{
                return off, errors.New("MANIFEST HMAC is required (length cannot be 0)")
        }</span>
        <span class="cov0" title="0">if len(buf) &lt; off+hmacLen </span><span class="cov0" title="0">{
                return off, errors.New("buffer too short for MANIFEST HMAC")
        }</span>
        <span class="cov0" title="0">rd.HMAC = make([]byte, hmacLen)
        copy(rd.HMAC, buf[off:off+hmacLen])
        off += hmacLen

        // Unpack JSON data length (uint16) + JSON data
        if len(buf) &lt; off+2 </span><span class="cov0" title="0">{
                return off, errors.New("buffer too short for MANIFEST JSON length")
        }</span>
        <span class="cov0" title="0">jsonLen := int(buf[off])&lt;&lt;8 | int(buf[off+1])
        off += 2

        if len(buf) &lt; off+jsonLen </span><span class="cov0" title="0">{
                return off, errors.New("buffer too short for MANIFEST JSON data")
        }</span>

        // Unmarshal JSON fields (not Format or HMAC)
        <span class="cov0" title="0">var jsonFields struct {
                ChunkCount uint16                 `json:"chunk_count"`
                ChunkSize  uint16                 `json:"chunk_size,omitempty"`
                Metadata   map[string]interface{} `json:"metadata,omitempty"`
                Payload    []byte                 `json:"payload,omitempty"`
        }
        if err := json.Unmarshal(buf[off:off+jsonLen], &amp;jsonFields); err != nil </span><span class="cov0" title="0">{
                return off, fmt.Errorf("failed to unmarshal MANIFEST JSON: %v", err)
        }</span>

        // Copy JSON fields to struct
        <span class="cov0" title="0">rd.ChunkCount = jsonFields.ChunkCount
        rd.ChunkSize = jsonFields.ChunkSize
        rd.Metadata = jsonFields.Metadata
        rd.Payload = jsonFields.Payload

        off += jsonLen
        return off, nil</span>
}

func (rd *MANIFEST) Copy(dest dns.PrivateRdata) error <span class="cov0" title="0">{
        d := dest.(*MANIFEST)
        d.Format = rd.Format
        if rd.HMAC != nil </span><span class="cov0" title="0">{
                d.HMAC = make([]byte, len(rd.HMAC))
                copy(d.HMAC, rd.HMAC)
        }</span>
        <span class="cov0" title="0">d.ChunkCount = rd.ChunkCount
        d.ChunkSize = rd.ChunkSize
        if rd.Metadata != nil </span><span class="cov0" title="0">{
                d.Metadata = make(map[string]interface{})
                for k, v := range rd.Metadata </span><span class="cov0" title="0">{
                        d.Metadata[k] = v
                }</span>
        }
        <span class="cov0" title="0">if rd.Payload != nil </span><span class="cov0" title="0">{
                d.Payload = make([]byte, len(rd.Payload))
                copy(d.Payload, rd.Payload)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (rd *MANIFEST) Len() int <span class="cov0" title="0">{
        // Format (1 byte) + HMAC length (2 bytes) + HMAC (variable) + JSON length (2 bytes) + JSON (variable)
        jsonFields := struct {
                ChunkCount uint16                 `json:"chunk_count"`
                ChunkSize  uint16                 `json:"chunk_size,omitempty"`
                Metadata   map[string]interface{} `json:"metadata,omitempty"`
                Payload    []byte                 `json:"payload,omitempty"`
        }{
                ChunkCount: rd.ChunkCount,
                ChunkSize:  rd.ChunkSize,
                Metadata:   rd.Metadata,
                Payload:    rd.Payload,
        }
        jsonBytes, _ := json.Marshal(jsonFields)
        hmacLen := 0
        if rd.HMAC != nil </span><span class="cov0" title="0">{
                hmacLen = len(rd.HMAC)
        }</span>
        <span class="cov0" title="0">return 1 + // Format
                2 + // HMAC length
                hmacLen + // HMAC
                2 + // JSON length
                len(jsonBytes)</span> // JSON data
}

func RegisterMANIFESTRR() error <span class="cov8" title="1">{
        dns.PrivateHandle("MANIFEST", TypeMANIFEST, NewMANIFEST)
        // Explicitly set TypeToString to use "MANIFEST" for printing
        dns.TypeToString[TypeMANIFEST] = "MANIFEST"
        return nil
}</span>

// GetHMACData returns the data that should be HMAC'd for this manifest.
// This includes Format + JSON fields (but NOT the HMAC field itself).
// The caller should calculate HMAC-SHA256 over this data using the long-term HPKE key.
func (rd *MANIFEST) GetHMACData() ([]byte, error) <span class="cov0" title="0">{
        // Pack Format (1 byte)
        buf := make([]byte, 1)
        buf[0] = rd.Format

        // Marshal JSON fields (not Format or HMAC)
        jsonFields := struct {
                ChunkCount uint16                 `json:"chunk_count"`
                ChunkSize  uint16                 `json:"chunk_size,omitempty"`
                Metadata   map[string]interface{} `json:"metadata,omitempty"`
                Payload    []byte                 `json:"payload,omitempty"`
        }{
                ChunkCount: rd.ChunkCount,
                ChunkSize:  rd.ChunkSize,
                Metadata:   rd.Metadata,
                Payload:    rd.Payload,
        }
        jsonBytes, err := json.Marshal(jsonFields)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal MANIFEST JSON for HMAC: %v", err)
        }</span>

        // Append JSON data (will be length-prefixed in actual Pack, but for HMAC we include it directly)
        // Actually, for HMAC we should include the same structure as Pack (Format + JSON length + JSON data)
        <span class="cov0" title="0">jsonLenBytes := make([]byte, 2)
        jsonLenBytes[0] = byte(len(jsonBytes) &gt;&gt; 8)
        jsonLenBytes[1] = byte(len(jsonBytes))

        // Return Format + JSON length + JSON data
        result := append(buf, jsonLenBytes...)
        result = append(result, jsonBytes...)
        return result, nil</span>
}

// CalculateHMAC calculates and sets the HMAC field for this manifest.
// The HMAC key should be derived from the long-term HPKE key.
// This should be called before Pack().
func (rd *MANIFEST) CalculateHMAC(hmacKey []byte) error <span class="cov0" title="0">{
        if len(hmacKey) == 0 </span><span class="cov0" title="0">{
                return errors.New("HMAC key cannot be empty")
        }</span>

        <span class="cov0" title="0">hmacData, err := rd.GetHMACData()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">mac := hmac.New(sha256.New, hmacKey)
        mac.Write(hmacData)
        rd.HMAC = mac.Sum(nil)

        return nil</span>
}

// VerifyHMAC verifies the HMAC field for this manifest.
// The HMAC key should be derived from the long-term HPKE key.
// Returns true if HMAC is valid, false otherwise.
func (rd *MANIFEST) VerifyHMAC(hmacKey []byte) (bool, error) <span class="cov0" title="0">{
        if rd.HMAC == nil </span><span class="cov0" title="0">{
                return false, errors.New("MANIFEST HMAC is not set")
        }</span>
        <span class="cov0" title="0">if len(hmacKey) == 0 </span><span class="cov0" title="0">{
                return false, errors.New("HMAC key cannot be empty")
        }</span>

        <span class="cov0" title="0">hmacData, err := rd.GetHMACData()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">mac := hmac.New(sha256.New, hmacKey)
        mac.Write(hmacData)
        expectedHMAC := mac.Sum(nil)

        // Use constant-time comparison to prevent timing attacks
        return hmac.Equal(rd.HMAC, expectedHMAC), nil</span>
}

</pre>
		
		<pre class="file" id="file11" style="display: none">/*
 * Copyright (c) 2024 Johan Stenstam, johani@johani.org
 */

package core

import (
        "errors"
        "fmt"

        "github.com/miekg/dns"
)

// example.com. IN MSIGNER ON API multisigner.provider.com.
// example.com. IN MSIGNER OFF 53 ms-conductor.signerco.net.

func init() <span class="cov8" title="1">{
        RegisterMsignerRR()
}</span>

// const TypeMSIGNER = 0x0F9C

type MSIGNER struct {
        State  uint8         // 0=OFF, 1=ON
        Method MsignerMethod // 1=DNS, 2=API
        //        Port   uint16
        Target string
}

type MsignerMethod uint8

const (
        MsignerMethodDNS = 1
        MsignerMethodAPI = 2
        MsignerStateON   = 1
        MsignerStateOFF  = 0
)

var StateToString = map[uint8]string{
        MsignerStateON:  "ON",
        MsignerStateOFF: "OFF",
}

var StringToState = map[string]uint8{
        "ON":  MsignerStateON,
        "OFF": MsignerStateOFF,
}

var MsignerMethodToString = map[MsignerMethod]string{
        MsignerMethodDNS: "DNS",
        MsignerMethodAPI: "API",
}

var StringToMsignerMethod = map[string]MsignerMethod{
        "DNS": MsignerMethodDNS,
        "API": MsignerMethodAPI,
}

func NewMSIGNER() dns.PrivateRdata <span class="cov0" title="0">{ return new(MSIGNER) }</span>

func (rd MSIGNER) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s\t%s %s", StateToString[rd.State], MsignerMethodToString[rd.Method], rd.Target)
}</span>

func (rd *MSIGNER) Parse(txt []string) error <span class="cov8" title="1">{
        if len(txt) != 3 </span><span class="cov0" title="0">{
                return errors.New("MSIGNER requires a state, a sync method and a target")
        }</span>
        <span class="cov8" title="1">state, exist := StringToState[txt[0]]
        if !exist </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid MSIGNER type: %s", txt[0])
        }</span>

        <span class="cov8" title="1">method, exist := StringToMsignerMethod[txt[1]]
        if !exist </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid MSIGNER sync method: %s", txt[1])
        }</span>

        <span class="cov8" title="1">tgt := dns.Fqdn(txt[2])
        if _, ok := dns.IsDomainName(tgt); !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid MSIGNER target: %s", txt[2])
        }</span>

        <span class="cov8" title="1">rd.State = state
        rd.Method = method
        rd.Target = tgt

        return nil</span>
}

func (rd *MSIGNER) Pack(buf []byte) (int, error) <span class="cov0" title="0">{
        var off int
        off, err := packUint8(rd.State, buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">off, err = packUint8(uint8(rd.Method), buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">off, err = dns.PackDomainName(rd.Target, buf, off, nil, false)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">return off, nil</span>
}

func (rd *MSIGNER) Unpack(buf []byte) (int, error) <span class="cov0" title="0">{
        var off = 0
        var err error
        var tmp uint8

        rd.State, off, err = unpackUint8(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">if off == len(buf) </span><span class="cov0" title="0">{
                return off, nil
        }</span>

        <span class="cov0" title="0">tmp, off, err = unpackUint8(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">rd.Method = MsignerMethod(tmp)
        if off == len(buf) </span><span class="cov0" title="0">{
                return off, nil
        }</span>

        <span class="cov0" title="0">rd.Target, off, err = dns.UnpackDomainName(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">return off, nil</span>
}

func (rd *MSIGNER) Copy(dest dns.PrivateRdata) error <span class="cov0" title="0">{
        cp := make([]byte, rd.Len())
        _, err := rd.Pack(cp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">d := dest.(*MSIGNER)
        d.State = rd.State
        d.Method = rd.Method
        d.Target = rd.Target
        return nil</span>
}

func (rd *MSIGNER) Len() int <span class="cov0" title="0">{
        //        return 1 + 1 + 2 + len(rd.Target) + 1 // add 1 for terminating 0
        return 1 + 1 + len(rd.Target) + 1 // add 1 for terminating 0
}</span>

func RegisterMsignerRR() error <span class="cov8" title="1">{
        dns.PrivateHandle("MSIGNER", TypeMSIGNER, NewMSIGNER)
        // Explicitly set TypeToString to use "MSIGNER" for printing
        dns.TypeToString[TypeMSIGNER] = "MSIGNER"
        return nil
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
 * Copyright (c) 2024 Johan Stenstam, johani@johani.org
 */

package core

import (
        "errors"
        "fmt"
        "strconv"

        "github.com/miekg/dns"
)

func init() <span class="cov8" title="1">{
        RegisterNotifyRR()
}</span>

// const TypeNOTIFY = 0x0F9A

type NOTIFY struct {
        Type   uint16
        Scheme uint8
        Port   uint16
        Target string
}

func NewNOTIFY() dns.PrivateRdata <span class="cov0" title="0">{ return new(NOTIFY) }</span>

func (rd NOTIFY) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s\t%d %d %s", dns.TypeToString[rd.Type], rd.Scheme, rd.Port, rd.Target)
}</span>

func (rd *NOTIFY) Parse(txt []string) error <span class="cov8" title="1">{
        if len(txt) != 4 </span><span class="cov0" title="0">{
                return errors.New("NOTIFY requires a type, a scheme, a port and a target")
        }</span>
        <span class="cov8" title="1">t := dns.StringToType[txt[0]]
        if t == 0 </span><span class="cov0" title="0">{
                return errors.New("invalid type in NOTIFY specification")
        }</span>

        <span class="cov8" title="1">scheme, err := strconv.Atoi(txt[1])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid NOTIFY scheme: %s. Error: %v", txt[1], err)
        }</span>

        <span class="cov8" title="1">port, err := strconv.Atoi(txt[2])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid NOTIFY port: %s. Error: %v", txt[2], err)
        }</span>

        <span class="cov8" title="1">tgt := dns.Fqdn(txt[3])
        if _, ok := dns.IsDomainName(tgt); !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid NOTIFY target: %s. Error: %v", txt[3], err)
        }</span>

        <span class="cov8" title="1">rd.Type = t
        rd.Scheme = uint8(scheme)
        rd.Port = uint16(port)
        rd.Target = tgt

        return nil</span>
}

func (rd *NOTIFY) Pack(buf []byte) (int, error) <span class="cov0" title="0">{
        var off int
        off, err := packUint16(rd.Type, buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">off, err = packUint8(rd.Scheme, buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">off, err = packUint16(rd.Port, buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">off, err = dns.PackDomainName(rd.Target, buf, off, nil, false)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>

        <span class="cov0" title="0">return off, nil</span>
}

func (rd *NOTIFY) Unpack(buf []byte) (int, error) <span class="cov0" title="0">{
        var off = 0
        var err error

        rd.Type, off, err = unpackUint16(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">if off == len(buf) </span><span class="cov0" title="0">{
                return off, nil
        }</span>

        <span class="cov0" title="0">rd.Scheme, off, err = unpackUint8(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">if off == len(buf) </span><span class="cov0" title="0">{
                return off, nil
        }</span>

        <span class="cov0" title="0">rd.Port, off, err = unpackUint16(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">if off == len(buf) </span><span class="cov0" title="0">{
                return off, nil
        }</span>

        <span class="cov0" title="0">rd.Target, off, err = dns.UnpackDomainName(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">return off, nil</span>
}

func (rd *NOTIFY) Copy(dest dns.PrivateRdata) error <span class="cov0" title="0">{
        cp := make([]byte, rd.Len())
        _, err := rd.Pack(cp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">d := dest.(*NOTIFY)
        d.Type = rd.Type
        d.Scheme = rd.Scheme
        d.Port = rd.Port
        d.Target = rd.Target
        return nil</span>
}

func (rd *NOTIFY) Len() int <span class="cov0" title="0">{
        return 1 + 2 + 2 + len(rd.Target) + 1 // add 1 for terminating 0
}</span>

func RegisterNotifyRR() error <span class="cov8" title="1">{
        dns.PrivateHandle("NOTIFY", TypeNOTIFY, NewNOTIFY)
        // Explicitly set TypeToString to use "NOTIFY" for printing
        dns.TypeToString[TypeNOTIFY] = "NOTIFY"
        return nil
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
 * Copyright (c) 2025 Johan Stenstam, johani@johani.org
 */

package core

import (
        "errors"
        "fmt"
        "strings"

        "github.com/miekg/dns"
)

func init() <span class="cov8" title="1">{
        RegisterTsyncRR()
}</span>

// TSYNC is a private/custom RRtype similar in style to DSYNC.
// RDATA fields (wire format order):
// - Type: uint16 (the RRtype variant within TSYNC namespace; typically dns.TypeTSYNC)
// - Alias: domain name (mandatory; must be a valid FQDN, cannot be empty)
// - Transports: string (optional; e.g., "doq=30,dot=20", can be empty)
// - V4addr: string (optional; comma-separated list of IPv4 addresses, can be empty)
// - V6addr: string (optional; comma-separated list of IPv6 addresses, can be empty)
type TSYNC struct {
        Type       uint16
        Alias      string
        Transports string
        V4addr     string
        V6addr     string
}

func NewTSYNC() dns.PrivateRdata <span class="cov0" title="0">{ return new(TSYNC) }</span>

func (rd TSYNC) String() string <span class="cov8" title="1">{
        // Render keyed form in stable order, always including keys
        return fmt.Sprintf("%s %q %q %q",
                rd.Alias,
                fmt.Sprintf("transport=%s", rd.Transports),
                fmt.Sprintf("v4=%s", rd.V4addr),
                fmt.Sprintf("v6=%s", rd.V6addr),
        )
}</span>

func (rd *TSYNC) Parse(txt []string) error <span class="cov8" title="1">{
        // Accept either 5 tokens (&lt;TYPE&gt; &lt;alias&gt; &lt;transports&gt; &lt;v4addr&gt; &lt;v6addr&gt;) or 4 tokens (&lt;TYPE&gt; &lt;alias&gt; &lt;transports&gt; &lt;v4addr&gt; &lt;v6addr&gt;)
        // Also accept empty/missing v4/v6 as empty strings.
        if len(txt) &lt; 4 </span><span class="cov0" title="0">{
                return errors.New("TSYNC: requires at least 4 fields")
        }</span>
        <span class="cov8" title="1">var t uint16
        idx := 0
        if len(txt) &gt;= 4 </span><span class="cov8" title="1">{
                // First token may be the type mnemonic
                if tt := dns.StringToType[txt[0]]; tt != 0 </span><span class="cov0" title="0">{
                        t = tt
                        idx = 1
                }</span> else<span class="cov8" title="1"> {
                        // first token is not a type mnemonic, treat all tokens as data
                        t = TypeTSYNC
                        idx = 0
                }</span>
        } else<span class="cov0" title="0"> if len(txt) &gt;= 1 </span><span class="cov0" title="0">{
                // No explicit type token provided; default to TypeTSYNC
                t = TypeTSYNC
                idx = 0
        }</span>

        // Collect remaining fields; support keyed tokens in arbitrary order and legacy positional
        <span class="cov8" title="1">var alias, transports, v4addr, v6addr string
        // Helper to assign legacy positionally
        assignPositional := func(val string) </span><span class="cov8" title="1">{
                if alias == "" </span><span class="cov8" title="1">{
                        alias = dns.Fqdn(val)
                        return
                }</span>
                <span class="cov0" title="0">if transports == "" </span><span class="cov0" title="0">{
                        transports = val
                        return
                }</span>
                <span class="cov0" title="0">if v4addr == "" </span><span class="cov0" title="0">{
                        v4addr = val
                        return
                }</span>
                <span class="cov0" title="0">if v6addr == "" </span><span class="cov0" title="0">{
                        v6addr = val
                        return
                }</span>
        }

        <span class="cov8" title="1">for ; idx &lt; len(txt); idx++ </span><span class="cov8" title="1">{
                raw := strings.TrimSpace(txt[idx])
                raw = stripQuotes(raw)
                if raw == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.Contains(raw, "=") </span><span class="cov8" title="1">{
                        kv := strings.SplitN(raw, "=", 2)
                        key := strings.ToLower(strings.TrimSpace(kv[0]))
                        val := strings.TrimSpace(kv[1])
                        val = stripQuotes(val)
                        switch key </span>{
                        case "alias":<span class="cov0" title="0">
                                alias = dns.Fqdn(val)</span>
                        case "transport", "transports":<span class="cov8" title="1">
                                transports = val</span>
                        case "v4", "ipv4", "ipv4addrs", "ipv4addr", "ipv4s":<span class="cov8" title="1">
                                v4addr = val</span>
                        case "v6", "ipv6", "ipv6addrs", "ipv6addr", "ipv6s":<span class="cov8" title="1">
                                v6addr = val</span>
                        default:<span class="cov0" title="0">
                                // Unknown key; treat as positional fallback to avoid hard failure
                                assignPositional(raw)</span>
                        }
                } else<span class="cov8" title="1"> {
                        // No key, legacy positional token
                        assignPositional(raw)
                }</span>
        }

        <span class="cov8" title="1">rd.Type = t
        if alias == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("TSYNC: alias is required (use '.' for none)")
        }</span>
        // Ensure alias is a valid FQDN
        <span class="cov8" title="1">alias = dns.Fqdn(alias)
        if _, ok := dns.IsDomainName(alias); !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("TSYNC: invalid alias domain name: %q", alias)
        }</span>
        <span class="cov8" title="1">rd.Alias = alias
        rd.Transports = transports
        rd.V4addr = v4addr
        rd.V6addr = v6addr
        return nil</span>
}

func (rd *TSYNC) Pack(buf []byte) (int, error) <span class="cov0" title="0">{
        var off int
        var err error

        off, err = packUint16(rd.Type, buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">off, err = dns.PackDomainName(rd.Alias, buf, off, nil, false)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">off, err = packString(rd.Transports, buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">off, err = packString(rd.V4addr, buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">off, err = packString(rd.V6addr, buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">return off, nil</span>
}

func (rd *TSYNC) Unpack(buf []byte) (int, error) <span class="cov0" title="0">{
        var off int
        var err error

        rd.Type, off, err = unpackUint16(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        // Alias is mandatory - if buffer ends here, it's an error
        <span class="cov0" title="0">if off == len(buf) </span><span class="cov0" title="0">{
                return off, errors.New("TSYNC: missing mandatory Alias field")
        }</span>
        <span class="cov0" title="0">rd.Alias, off, err = dns.UnpackDomainName(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        // Validate that Alias is not empty
        <span class="cov0" title="0">if rd.Alias == "" </span><span class="cov0" title="0">{
                return off, errors.New("TSYNC: Alias field cannot be empty")
        }</span>
        // Remaining fields are optional - if buffer ends, set to empty strings
        <span class="cov0" title="0">if off == len(buf) </span><span class="cov0" title="0">{
                rd.Transports = ""
                rd.V4addr = ""
                rd.V6addr = ""
                return off, nil
        }</span>
        <span class="cov0" title="0">rd.Transports, off, err = unpackString(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">if off == len(buf) </span><span class="cov0" title="0">{
                rd.V4addr = ""
                rd.V6addr = ""
                return off, nil
        }</span>
        <span class="cov0" title="0">rd.V4addr, off, err = unpackString(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">if off == len(buf) </span><span class="cov0" title="0">{
                rd.V6addr = ""
                return off, nil
        }</span>
        <span class="cov0" title="0">rd.V6addr, off, err = unpackString(buf, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">return off, nil</span>
}

func (rd *TSYNC) Copy(dest dns.PrivateRdata) error <span class="cov0" title="0">{
        // Copy via field assignment (safe, strings are immutable header pairs)
        d, ok := dest.(*TSYNC)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("TSYNC: Copy: dest is not a *TSYNC")
        }</span>
        <span class="cov0" title="0">d.Type = rd.Type
        d.Alias = rd.Alias
        d.Transports = rd.Transports
        d.V4addr = rd.V4addr
        d.V6addr = rd.V6addr
        return nil</span>
}

func (rd *TSYNC) Len() int <span class="cov0" title="0">{
        // 2 bytes for Type +
        // for each string: 2 bytes length + len(data)
        // Alias uses domain name wire format: sum(1+len(label)) + root(1)
        aliasLen := domainNameWireLen(rd.Alias)
        return 2 + aliasLen + 2 + len(rd.Transports) + 2 + len(rd.V4addr) + 2 + len(rd.V6addr)
}</span>

func RegisterTsyncRR() error <span class="cov8" title="1">{
        dns.PrivateHandle("TSYNC", TypeTSYNC, NewTSYNC)
        // Explicitly set TypeToString to use "TSYNC" for printing
        dns.TypeToString[TypeTSYNC] = "TSYNC"
        return nil
}</span>

// Helpers for packing/unpacking length-prefixed strings (uint16 length)
func packString(s string, msg []byte, off int) (int, error) <span class="cov0" title="0">{
        var err error
        off, err = packUint16(uint16(len(s)), msg, off)
        if err != nil </span><span class="cov0" title="0">{
                return off, err
        }</span>
        <span class="cov0" title="0">if off+len(s) &gt; len(msg) </span><span class="cov0" title="0">{
                return off, errors.New("overflow packing string")
        }</span>
        <span class="cov0" title="0">copy(msg[off:], []byte(s))
        return off + len(s), nil</span>
}

func unpackString(msg []byte, off int) (string, int, error) <span class="cov0" title="0">{
        l, off1, err := unpackUint16(msg, off)
        if err != nil </span><span class="cov0" title="0">{
                return "", off1, err
        }</span>
        <span class="cov0" title="0">if int(off1)+int(l) &gt; len(msg) </span><span class="cov0" title="0">{
                return "", len(msg), errors.New("overflow unpacking string")
        }</span>
        <span class="cov0" title="0">s := string(msg[off1 : off1+int(l)])
        return s, off1 + int(l), nil</span>
}

func stripQuotes(s string) string <span class="cov8" title="1">{
        if len(s) &gt;= 2 </span><span class="cov8" title="1">{
                if (s[0] == '"' &amp;&amp; s[len(s)-1] == '"') || (s[0] == '\'' &amp;&amp; s[len(s)-1] == '\'') </span><span class="cov0" title="0">{
                        return s[1 : len(s)-1]
                }</span>
        }
        <span class="cov8" title="1">return s</span>
}

// domainNameWireLen returns the length in bytes of a domain name in DNS wire format.
// It is sum(1+len(label)) for each label plus the root label (1). "." =&gt; 1.
func domainNameWireLen(name string) int <span class="cov0" title="0">{
        n := dns.Fqdn(strings.TrimSpace(name))
        if n == "." </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">labels := dns.SplitDomainName(n)
        // Start with 1 for the root label
        total := 1
        for _, lbl := range labels </span><span class="cov0" title="0">{
                total += 1 + len(lbl)
        }</span>
        <span class="cov0" title="0">return total</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
 * Copyright (c) 2024 Johan Stenstam, johan.stenstam@internetstiftelsen.se
 */
package core

import (
        "fmt"
        "log"

        "github.com/miekg/dns"
)

// RRsetDiffer compares old and new DNS resource record slices for a given RR type in a zone, ignoring RRSIG records.
// It returns: a boolean that is true if the RRsets differ, a slice of records present in newrrs but not in oldrrs (adds), and a slice of records present in oldrrs but not in newrrs (removes).
// RRsetDiffer compares old and new DNS resource records of a specific type in a zone and reports whether the RRsets differ,
// returning slices of records that were added and removed.
 // It ignores RRSIG records and determines equality using dns.IsDuplicate. When verbose or debug are true, comparison details
 // are written to the provided logger.
func RRsetDiffer(zone string, newrrs, oldrrs []dns.RR, rrtype uint16, lg *log.Logger, verbose, debug bool) (bool, []dns.RR, []dns.RR) <span class="cov0" title="0">{
        var match, rrsets_differ bool
        typestr := dns.TypeToString[rrtype]
        adds := []dns.RR{}
        removes := []dns.RR{}

        if debug </span><span class="cov0" title="0">{
                lg.Printf("*** RRD: Comparing %s RRsets for %s:", typestr, zone)
                lg.Printf("-------- Old set for %s %s:", zone, typestr)
                for _, rr := range oldrrs </span><span class="cov0" title="0">{
                        lg.Printf("%s", rr.String())
                }</span>
                <span class="cov0" title="0">lg.Printf("-------- New set for %s %s:", zone, typestr)
                for _, rr := range newrrs </span><span class="cov0" title="0">{
                        lg.Printf("%s", rr.String())
                }</span>
        }
        // compare oldrrs to newrrs
        <span class="cov0" title="0">for _, orr := range oldrrs </span><span class="cov0" title="0">{
                if dns.TypeToString[orr.Header().Rrtype] == "RRSIG" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">match = false
                for _, nrr := range newrrs </span><span class="cov0" title="0">{
                        if dns.IsDuplicate(orr, nrr) </span><span class="cov0" title="0">{
                                match = true
                                break</span>
                        }
                }
                // if we get here w/o match then this orr has no equal nrr
                <span class="cov0" title="0">if !match </span><span class="cov0" title="0">{
                        rrsets_differ = true
                        removes = append(removes, orr)
                }</span>
        }

        // compare newrrs to oldrrs
        <span class="cov0" title="0">for _, nrr := range newrrs </span><span class="cov0" title="0">{
                if dns.TypeToString[nrr.Header().Rrtype] == "RRSIG" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">match = false
                for _, orr := range oldrrs </span><span class="cov0" title="0">{
                        if dns.IsDuplicate(nrr, orr) </span><span class="cov0" title="0">{
                                match = true
                                break</span>
                        }
                }
                // if we get here w/o match then this nrr has no equal orr
                <span class="cov0" title="0">if !match </span><span class="cov0" title="0">{
                        rrsets_differ = true
                        adds = append(adds, nrr)
                }</span>
        }
        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                lg.Printf("*** RRD: RRsetDiffer: Zone %s %s rrsets_differ: %v\n***Adds: %v\n***Removes: %v", zone, typestr, rrsets_differ, adds, removes)
        }</span>
        <span class="cov0" title="0">return rrsets_differ, adds, removes</span>
}

func (rrset *RRset) RRsetDiffer(newrrset *RRset, lg *log.Logger, verbose, debug bool) (bool, []dns.RR, []dns.RR) <span class="cov0" title="0">{
        emptySlice := []dns.RR{}

        // Nil guard: if either RRset is nil, treat as no difference
        if rrset == nil &amp;&amp; newrrset == nil </span><span class="cov0" title="0">{
                return false, emptySlice, emptySlice
        }</span>
        <span class="cov0" title="0">if rrset == nil || newrrset == nil </span><span class="cov0" title="0">{
                // One is nil, the other is not - they differ
                return true, emptySlice, emptySlice
        }</span>

        // Treat nil .RRs as empty slices
        <span class="cov0" title="0">oldrrs := rrset.RRs
        if oldrrs == nil </span><span class="cov0" title="0">{
                oldrrs = emptySlice
        }</span>
        <span class="cov0" title="0">newrrs := newrrset.RRs
        if newrrs == nil </span><span class="cov0" title="0">{
                newrrs = emptySlice
        }</span>

        <span class="cov0" title="0">var match, rrsets_differ bool
        typestr := dns.TypeToString[rrset.RRtype]
        adds := []dns.RR{}
        removes := []dns.RR{}

        if debug </span><span class="cov0" title="0">{
                lg.Printf("*** RRD: Comparing %s RRsets for %s:", typestr, rrset.Name)
                lg.Printf("-------- Old set for %s %s:", rrset.Name, typestr)
                for _, rr := range oldrrs </span><span class="cov0" title="0">{
                        lg.Printf("%s", rr.String())
                }</span>
                <span class="cov0" title="0">lg.Printf("-------- New set for %s %s:", rrset.Name, typestr)
                for _, rr := range newrrs </span><span class="cov0" title="0">{
                        lg.Printf("%s", rr.String())
                }</span>
        }
        // compare oldrrs to newrrs
        <span class="cov0" title="0">for _, orr := range oldrrs </span><span class="cov0" title="0">{
                if orr.Header().Rrtype == dns.TypeRRSIG </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">match = false
                for _, nrr := range newrrs </span><span class="cov0" title="0">{
                        if dns.IsDuplicate(orr, nrr) </span><span class="cov0" title="0">{
                                match = true
                                break</span>
                        }
                }
                // if we get here w/o match then this orr has no equal nrr
                <span class="cov0" title="0">if !match </span><span class="cov0" title="0">{
                        rrsets_differ = true
                        removes = append(removes, orr)
                }</span>
        }

        // compare newrrs to oldrrs
        <span class="cov0" title="0">for _, nrr := range newrrs </span><span class="cov0" title="0">{
                if nrr.Header().Rrtype == dns.TypeRRSIG </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">match = false
                for _, orr := range oldrrs </span><span class="cov0" title="0">{
                        if dns.IsDuplicate(nrr, orr) </span><span class="cov0" title="0">{
                                match = true
                                break</span>
                        }
                }
                // if we get here w/o match then this nrr has no equal orr
                <span class="cov0" title="0">if !match </span><span class="cov0" title="0">{
                        rrsets_differ = true
                        adds = append(adds, nrr)
                }</span>
        }
        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                lg.Printf("*** RRD: RRsetDiffer: Zone %s %s rrsets_differ: %v\n***Adds: %v\n***Removes: %v", rrset.Name, typestr, rrsets_differ, adds, removes)
        }</span>
        <span class="cov0" title="0">return rrsets_differ, adds, removes</span>
}

// RRSIGsDiffer compares two slices of RRSIGs and returns true if they differ.
// Two RRSIG slices are considered equal if they contain the same RRSIGs (using dns.IsDuplicate for comparison),
// regardless of order. Returns true if the RRSIGs differ, false if they are the same.
func (rrset *RRset) RRSIGsDiffer(newrrset *RRset) bool <span class="cov0" title="0">{
        // Nil guard: if both RRsets are nil, RRSIGs are the same (both empty)
        if rrset == nil &amp;&amp; newrrset == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // If one is nil and the other is not, check if the non-nil one has any RRSIGs
        <span class="cov0" title="0">if rrset == nil </span><span class="cov0" title="0">{
                // Old is nil (no RRSIGs), check if new has any
                if newrrset.RRSIGs == nil || len(newrrset.RRSIGs) == 0 </span><span class="cov0" title="0">{
                        return false // Both effectively empty
                }</span>
                <span class="cov0" title="0">return true</span> // New has RRSIGs, old doesn't
        }
        <span class="cov0" title="0">if newrrset == nil </span><span class="cov0" title="0">{
                // New is nil (no RRSIGs), check if old has any
                if rrset.RRSIGs == nil || len(rrset.RRSIGs) == 0 </span><span class="cov0" title="0">{
                        return false // Both effectively empty
                }</span>
                <span class="cov0" title="0">return true</span> // Old has RRSIGs, new doesn't
        }

        // Both are non-nil, treat nil .RRSIGs as empty slices
        <span class="cov0" title="0">oldRRSIGs := rrset.RRSIGs
        if oldRRSIGs == nil </span><span class="cov0" title="0">{
                oldRRSIGs = []dns.RR{}
        }</span>
        <span class="cov0" title="0">newRRSIGs := newrrset.RRSIGs
        if newRRSIGs == nil </span><span class="cov0" title="0">{
                newRRSIGs = []dns.RR{}
        }</span>

        <span class="cov0" title="0">if len(oldRRSIGs) != len(newRRSIGs) </span><span class="cov0" title="0">{
                return true
        }</span>
        // Compare old RRSIGs to new RRSIGs
        <span class="cov0" title="0">for _, oldSig := range oldRRSIGs </span><span class="cov0" title="0">{
                found := false
                for _, newSig := range newRRSIGs </span><span class="cov0" title="0">{
                        if dns.IsDuplicate(oldSig, newSig) </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        // Compare new RRSIGs to old RRSIGs (check the other direction)
        <span class="cov0" title="0">for _, newSig := range newRRSIGs </span><span class="cov0" title="0">{
                found := false
                for _, oldSig := range oldRRSIGs </span><span class="cov0" title="0">{
                        if dns.IsDuplicate(newSig, oldSig) </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (rrset *RRset) RemoveRR(rr dns.RR, verbose, debug bool) <span class="cov0" title="0">{
        if debug </span><span class="cov0" title="0">{
                log.Printf("RemoveRR: Trying to remove '%s' from RRset %s %s", rr.String(), rrset.Name, dns.TypeToString[rr.Header().Rrtype])
        }</span>
        <span class="cov0" title="0">for i, r := range rrset.RRs </span><span class="cov0" title="0">{
                if debug </span><span class="cov0" title="0">{
                        log.Printf("RemoveRR: Comparing:\n%s\n%s\n", r.String(), rr.String())
                }</span>
                <span class="cov0" title="0">if dns.IsDuplicate(r, rr) </span><span class="cov0" title="0">{
                        rrset.RRs = append(rrset.RRs[:i], rrset.RRs[i+1:]...)
                        rrset.RRSIGs = []dns.RR{}
                        log.Printf("RemoveRR: *REMOVED* '%s' from RRset %s %s", rr.String(), rrset.Name, dns.TypeToString[rr.Header().Rrtype])
                        return
                }</span>
        }
}

// Add adds a RR to the RRset if it is not already present.
func (rrset *RRset) Add(rr dns.RR) <span class="cov0" title="0">{
        for _, rr2 := range rrset.RRs </span><span class="cov0" title="0">{
                if dns.IsDuplicate(rr, rr2) </span><span class="cov0" title="0">{
                        // log.Printf("rrset.Add: RR already present: %s", rr.String())
                        return
                }</span>
        }
        // log.Printf("rrset.Add: Adding RR: %s to RRset\n%v", rr.String(), rrset.RRs)
        <span class="cov0" title="0">rrset.RRs = append(rrset.RRs, rr)</span>
}

// Delete deletes a RR from the RRset if it is present.
func (rrset *RRset) Delete(rr dns.RR) <span class="cov0" title="0">{
        for i, rr2 := range rrset.RRs </span><span class="cov0" title="0">{
                if dns.IsDuplicate(rr, rr2) </span><span class="cov0" title="0">{
                        // log.Printf("rrset.Delete: Found RR: %s in RRset\n%v", rr.String(), rrset.RRs)
                        rrset.RRs = append(rrset.RRs[:i], rrset.RRs[i+1:]...)
                        return
                }</span>
        }
        // log.Printf("rrset.Delete: RR not found: %s", rr.String())
}

func (rrset *RRset) Clone() *RRset <span class="cov0" title="0">{
        if rrset == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">clone := &amp;RRset{
                Name:   rrset.Name,
                Class:  rrset.Class,
                RRtype: rrset.RRtype,
        }
        for _, rr := range rrset.RRs </span><span class="cov0" title="0">{
                if rr != nil </span><span class="cov0" title="0">{
                        clone.RRs = append(clone.RRs, dns.Copy(rr))
                }</span>
        }
        <span class="cov0" title="0">for _, sig := range rrset.RRSIGs </span><span class="cov0" title="0">{
                if sig != nil </span><span class="cov0" title="0">{
                        clone.RRSIGs = append(clone.RRSIGs, dns.Copy(sig))
                }</span>
        }
        <span class="cov0" title="0">return clone</span>
}

func (rrset *RRset) String(maxlen int) (out string) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        log.Printf("RRset.String: panic recovered: %v", r)
                        if out == "" </span><span class="cov0" title="0">{
                                out = fmt.Sprintf("(RRset.String panic: %v)\n", r)
                        }</span>
                }
                <span class="cov0" title="0">if out == "" </span><span class="cov0" title="0">{
                        // Fallback: ensure we always return something
                        log.Printf("RRset.String: WARNING - returning empty string, using fallback")
                        out = "(RRset.String returned empty string - this should not happen)\n"
                }</span>
        }()

        <span class="cov0" title="0">if rrset == nil </span><span class="cov0" title="0">{
                return "(nil RRset)\n"
        }</span>

        <span class="cov0" title="0">out = ""
        rrCount := 0
        if rrset.RRs != nil </span><span class="cov0" title="0">{
                rrCount = len(rrset.RRs)
                for _, rr := range rrset.RRs </span><span class="cov0" title="0">{
                        if rr == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">rrstr := rr.String() + "\n"
                        if maxlen &gt; 4 &amp;&amp; len(rrstr) &gt; maxlen </span><span class="cov0" title="0">{
                                rrstr = rrstr[:maxlen-4] + "...\n"
                        }</span>
                        <span class="cov0" title="0">out += rrstr</span>
                }
        }
        <span class="cov0" title="0">sigCount := 0
        if rrset.RRSIGs != nil </span><span class="cov0" title="0">{
                sigCount = len(rrset.RRSIGs)
                for _, sig := range rrset.RRSIGs </span><span class="cov0" title="0">{
                        if sig == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">sigstr := sig.String() + "\n"
                        if maxlen &gt; 4 &amp;&amp; len(sigstr) &gt; maxlen </span><span class="cov0" title="0">{
                                sigstr = sigstr[:maxlen-4] + "...\n"
                        }</span>
                        <span class="cov0" title="0">out += sigstr</span>
                }
        }

        <span class="cov0" title="0">if out == "" </span><span class="cov0" title="0">{
                typeStr := "UNKNOWN"
                if rrset.RRtype &gt; 0 </span><span class="cov0" title="0">{
                        if value, ok := dns.TypeToString[rrset.RRtype]; ok &amp;&amp; value != "" </span><span class="cov0" title="0">{
                                typeStr = value
                        }</span> else<span class="cov0" title="0"> {
                                typeStr = fmt.Sprintf("TYPE%d", rrset.RRtype)
                        }</span>
                }
                <span class="cov0" title="0">name := rrset.Name
                if name == "" </span><span class="cov0" title="0">{
                        name = "(empty)"
                }</span>
                <span class="cov0" title="0">out = fmt.Sprintf("(empty RRset: name=%q type=%s rrs=%d rrsigs=%d)\n",
                        name, typeStr, rrCount, sigCount)</span>
        }

        <span class="cov0" title="0">return out</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
 * Copyright (c) 2024 Johan Stenstam, johan.stenstam@internetstiftelsen.se
 */
package core

import (
        "fmt"
        "strconv"
        "strings"
)

// ParseTransportString parses a transport string like "doq:30,dot:20" into a map.
// - Keys are lower-cased and trimmed
// - Values must be integers in [0,100]
// - Duplicate keys are rejected
func ParseTransportString(s string) (map[string]uint8, error) <span class="cov0" title="0">{
        transports := make(map[string]uint8)
        s = strings.TrimSpace(s)
        if s == "" </span><span class="cov0" title="0">{
                return transports, nil
        }</span>
        <span class="cov0" title="0">parts := strings.Split(s, ",")
        for _, p := range parts </span><span class="cov0" title="0">{
                kv := strings.SplitN(strings.TrimSpace(p), ":", 2)
                if len(kv) != 2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("transport: bad token %q (want key:value)", p)
                }</span>
                <span class="cov0" title="0">k := strings.ToLower(strings.TrimSpace(kv[0]))
                vstr := strings.TrimSpace(kv[1])
                if k == "" || vstr == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("transport: empty key or value in %q", p)
                }</span>
                <span class="cov0" title="0">if _, exists := transports[k]; exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("transport: duplicate key %q", k)
                }</span>
                <span class="cov0" title="0">v64, err := strconv.ParseUint(vstr, 10, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("transport: bad value for %q: %v", k, err)
                }</span>
                <span class="cov0" title="0">v := uint8(v64)
                if v &gt; 100 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("transport: value for %q out of range: %d", k, v)
                }</span>
                <span class="cov0" title="0">transports[k] = v</span>
        }
        <span class="cov0" title="0">return transports, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
 * Stolen from https://github.com/miekg/dns/blob/master/scan.go
 */
package core

import (
        "bufio"
        "io"
        "strconv"
        "strings"

        "github.com/miekg/dns"
)

const maxTok = 512 // Token buffer start size, and growth size amount.

// The maximum depth of $INCLUDE directives supported by the
// ZoneParser API.
// const maxIncludeDepth = 7

// Tokenize a RFC 1035 zone file. The tokenizer will normalize it:
// * Add ownernames if they are left blank;
// * Suppress sequences of spaces;
// * Make each RR fit on one line (_NEWLINE is send as last)
// * Handle comments: ;
// * Handle braces - anywhere.
const (
        // Zonefile
        zEOF = iota
        zString
        zBlank
        zQuote
        zNewline
        zRrtpe
        zOwner
        zClass
        zDirOrigin   // $ORIGIN
        zDirTTL      // $TTL
        zDirInclude  // $INCLUDE
        zDirGenerate // $GENERATE
)

// ParseError is a parsing error. It contains the parse error and the location in the io.Reader
// where the error occurred.
type ParseError struct {
        file       string
        err        string
        wrappedErr error
        lex        lex
}

func (e *ParseError) Error() (s string) <span class="cov0" title="0">{
        if e.file != "" </span><span class="cov0" title="0">{
                s = e.file + ": "
        }</span>
        <span class="cov0" title="0">if e.err == "" &amp;&amp; e.wrappedErr != nil </span><span class="cov0" title="0">{
                e.err = e.wrappedErr.Error()
        }</span>
        <span class="cov0" title="0">s += "dns: " + e.err + ": " + strconv.QuoteToASCII(e.lex.token) + " at line: " +
                strconv.Itoa(e.lex.line) + ":" + strconv.Itoa(e.lex.column)
        return</span>
}

type lex struct {
        token  string // text of the token
        err    bool   // when true, token text has lexer error
        value  uint8  // value: zString, _BLANK, etc.
        torc   uint16 // type or class as parsed in the lexer, we only need to look this up in the grammar
        line   int    // line in the file
        column int    // column in the file
}

type zlexer struct {
        br io.ByteReader

        readErr error

        line   int
        column int

        comBuf  string
        comment string

        l       lex
        cachedL *lex

        brace  int
        quote  bool
        space  bool
        commt  bool
        rrtype bool
        owner  bool

        nextL bool

        eol bool // end-of-line
}

func newZLexer(r io.Reader) *zlexer <span class="cov8" title="1">{
        br, ok := r.(io.ByteReader)
        if !ok </span><span class="cov0" title="0">{
                br = bufio.NewReaderSize(r, 1024)
        }</span>

        <span class="cov8" title="1">return &amp;zlexer{
                br: br,

                line: 1,

                owner: true,
        }</span>
}

func (zl *zlexer) Err() error <span class="cov0" title="0">{
        if zl.readErr == io.EOF </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return zl.readErr</span>
}

// readByte returns the next byte from the input
func (zl *zlexer) readByte() (byte, bool) <span class="cov8" title="1">{
        if zl.readErr != nil </span><span class="cov8" title="1">{
                return 0, false
        }</span>

        <span class="cov8" title="1">c, err := zl.br.ReadByte()
        if err != nil </span><span class="cov8" title="1">{
                zl.readErr = err
                return 0, false
        }</span>

        // delay the newline handling until the next token is delivered,
        // fixes off-by-one errors when reporting a parse error.
        <span class="cov8" title="1">if zl.eol </span><span class="cov0" title="0">{
                zl.line++
                zl.column = 0
                zl.eol = false
        }</span>

        <span class="cov8" title="1">if c == '\n' </span><span class="cov0" title="0">{
                zl.eol = true
        }</span> else<span class="cov8" title="1"> {
                zl.column++
        }</span>

        <span class="cov8" title="1">return c, true</span>
}

func (zl *zlexer) Peek() lex <span class="cov0" title="0">{
        if zl.nextL </span><span class="cov0" title="0">{
                return zl.l
        }</span>

        <span class="cov0" title="0">l, ok := zl.Next()
        if !ok </span><span class="cov0" title="0">{
                return l
        }</span>

        <span class="cov0" title="0">if zl.nextL </span><span class="cov0" title="0">{
                // Cache l. Next returns zl.cachedL then zl.l.
                zl.cachedL = &amp;l
        }</span> else<span class="cov0" title="0"> {
                // In this case l == zl.l, so we just tell Next to return zl.l.
                zl.nextL = true
        }</span>

        <span class="cov0" title="0">return l</span>
}

func (zl *zlexer) Next() (lex, bool) <span class="cov8" title="1">{
        l := &amp;zl.l
        switch </span>{
        case zl.cachedL != nil:<span class="cov0" title="0">
                l, zl.cachedL = zl.cachedL, nil
                return *l, true</span>
        case zl.nextL:<span class="cov8" title="1">
                zl.nextL = false
                return *l, true</span>
        case l.err:<span class="cov0" title="0">
                // Parsing errors should be sticky.
                return lex{value: zEOF}, false</span>
        }

        <span class="cov8" title="1">var (
                str = make([]byte, maxTok) // Hold string text
                com = make([]byte, maxTok) // Hold comment text

                stri int // Offset in str (0 means empty)
                comi int // Offset in com (0 means empty)

                escape bool
        )

        if zl.comBuf != "" </span><span class="cov0" title="0">{
                comi = copy(com[:], zl.comBuf)
                zl.comBuf = ""
        }</span>

        <span class="cov8" title="1">zl.comment = ""

        for x, ok := zl.readByte(); ok; x, ok = zl.readByte() </span><span class="cov8" title="1">{
                l.line, l.column = zl.line, zl.column

                if stri &gt;= len(str) </span><span class="cov0" title="0">{
                        // if buffer length is insufficient, increase it.
                        str = append(str[:], make([]byte, maxTok)...)
                }</span>
                <span class="cov8" title="1">if comi &gt;= len(com) </span><span class="cov0" title="0">{
                        // if buffer length is insufficient, increase it.
                        com = append(com[:], make([]byte, maxTok)...)
                }</span>

                <span class="cov8" title="1">switch x </span>{
                case ' ', '\t':<span class="cov8" title="1">
                        if escape || zl.quote </span><span class="cov0" title="0">{
                                // Inside quotes or escaped this is legal.
                                str[stri] = x
                                stri++

                                escape = false
                                break</span>
                        }

                        <span class="cov8" title="1">if zl.commt </span><span class="cov0" title="0">{
                                com[comi] = x
                                comi++
                                break</span>
                        }

                        <span class="cov8" title="1">var retL lex
                        if stri == 0 </span>{<span class="cov0" title="0">
                                // Space directly in the beginning, handled in the grammar
                        }</span> else<span class="cov8" title="1"> if zl.owner </span><span class="cov8" title="1">{
                                // If we have a string and it's the first, make it an owner
                                l.value = zOwner
                                l.token = string(str[:stri])

                                // escape $... start with a \ not a $, so this will work
                                switch strings.ToUpper(l.token) </span>{
                                case "$TTL":<span class="cov0" title="0">
                                        l.value = zDirTTL</span>
                                case "$ORIGIN":<span class="cov0" title="0">
                                        l.value = zDirOrigin</span>
                                case "$INCLUDE":<span class="cov0" title="0">
                                        l.value = zDirInclude</span>
                                case "$GENERATE":<span class="cov0" title="0">
                                        l.value = zDirGenerate</span>
                                }

                                <span class="cov8" title="1">retL = *l</span>
                        } else<span class="cov0" title="0"> {
                                l.value = zString
                                l.token = string(str[:stri])

                                if !zl.rrtype </span><span class="cov0" title="0">{
                                        tokenUpper := strings.ToUpper(l.token)
                                        if t, ok := dns.StringToType[tokenUpper]; ok </span><span class="cov0" title="0">{
                                                l.value = zRrtpe
                                                l.torc = t

                                                zl.rrtype = true
                                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(tokenUpper, "TYPE") </span><span class="cov0" title="0">{
                                                t, ok := typeToInt(l.token)
                                                if !ok </span><span class="cov0" title="0">{
                                                        l.token = "unknown RR type"
                                                        l.err = true
                                                        return *l, true
                                                }</span>

                                                <span class="cov0" title="0">l.value = zRrtpe
                                                l.torc = t

                                                zl.rrtype = true</span>
                                        }

                                        <span class="cov0" title="0">if t, ok := dns.StringToClass[tokenUpper]; ok </span><span class="cov0" title="0">{
                                                l.value = zClass
                                                l.torc = t
                                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(tokenUpper, "CLASS") </span><span class="cov0" title="0">{
                                                t, ok := classToInt(l.token)
                                                if !ok </span><span class="cov0" title="0">{
                                                        l.token = "unknown class"
                                                        l.err = true
                                                        return *l, true
                                                }</span>

                                                <span class="cov0" title="0">l.value = zClass
                                                l.torc = t</span>
                                        }
                                }

                                <span class="cov0" title="0">retL = *l</span>
                        }

                        <span class="cov8" title="1">zl.owner = false

                        if !zl.space </span><span class="cov8" title="1">{
                                zl.space = true

                                l.value = zBlank
                                l.token = " "

                                if retL == (lex{}) </span><span class="cov0" title="0">{
                                        return *l, true
                                }</span>

                                <span class="cov8" title="1">zl.nextL = true</span>
                        }

                        <span class="cov8" title="1">if retL != (lex{}) </span><span class="cov8" title="1">{
                                return retL, true
                        }</span>
                case ';':<span class="cov0" title="0">
                        if escape || zl.quote </span><span class="cov0" title="0">{
                                // Inside quotes or escaped this is legal.
                                str[stri] = x
                                stri++

                                escape = false
                                break</span>
                        }

                        <span class="cov0" title="0">zl.commt = true
                        zl.comBuf = ""

                        if comi &gt; 1 </span><span class="cov0" title="0">{
                                // A newline was previously seen inside a comment that
                                // was inside braces and we delayed adding it until now.
                                com[comi] = ' ' // convert newline to space
                                comi++
                                if comi &gt;= len(com) </span><span class="cov0" title="0">{
                                        l.token = "comment length insufficient for parsing"
                                        l.err = true
                                        return *l, true
                                }</span>
                        }

                        <span class="cov0" title="0">com[comi] = ';'
                        comi++

                        if stri &gt; 0 </span><span class="cov0" title="0">{
                                zl.comBuf = string(com[:comi])

                                l.value = zString
                                l.token = string(str[:stri])
                                return *l, true
                        }</span>
                case '\r':<span class="cov0" title="0">
                        escape = false

                        if zl.quote </span><span class="cov0" title="0">{
                                str[stri] = x
                                stri++
                        }</span>

                        // discard if outside of quotes
                case '\n':<span class="cov0" title="0">
                        escape = false

                        // Escaped newline
                        if zl.quote </span><span class="cov0" title="0">{
                                str[stri] = x
                                stri++
                                break</span>
                        }

                        <span class="cov0" title="0">if zl.commt </span><span class="cov0" title="0">{
                                // Reset a comment
                                zl.commt = false
                                zl.rrtype = false

                                // If not in a brace this ends the comment AND the RR
                                if zl.brace == 0 </span><span class="cov0" title="0">{
                                        zl.owner = true

                                        l.value = zNewline
                                        l.token = "\n"
                                        zl.comment = string(com[:comi])
                                        return *l, true
                                }</span>

                                <span class="cov0" title="0">zl.comBuf = string(com[:comi])
                                break</span>
                        }

                        <span class="cov0" title="0">if zl.brace == 0 </span><span class="cov0" title="0">{
                                // If there is previous text, we should output it here
                                var retL lex
                                if stri != 0 </span><span class="cov0" title="0">{
                                        l.value = zString
                                        l.token = string(str[:stri])

                                        if !zl.rrtype </span><span class="cov0" title="0">{
                                                tokenUpper := strings.ToUpper(l.token)
                                                if t, ok := dns.StringToType[tokenUpper]; ok </span><span class="cov0" title="0">{
                                                        zl.rrtype = true

                                                        l.value = zRrtpe
                                                        l.torc = t
                                                }</span>
                                        }

                                        <span class="cov0" title="0">retL = *l</span>
                                }

                                <span class="cov0" title="0">l.value = zNewline
                                l.token = "\n"

                                zl.comment = zl.comBuf
                                zl.comBuf = ""
                                zl.rrtype = false
                                zl.owner = true

                                if retL != (lex{}) </span><span class="cov0" title="0">{
                                        zl.nextL = true
                                        return retL, true
                                }</span>

                                <span class="cov0" title="0">return *l, true</span>
                        }
                case '\\':<span class="cov0" title="0">
                        // comments do not get escaped chars, everything is copied
                        if zl.commt </span><span class="cov0" title="0">{
                                com[comi] = x
                                comi++
                                break</span>
                        }

                        // something already escaped must be in string
                        <span class="cov0" title="0">if escape </span><span class="cov0" title="0">{
                                str[stri] = x
                                stri++

                                escape = false
                                break</span>
                        }

                        // something escaped outside of string gets added to string
                        <span class="cov0" title="0">str[stri] = x
                        stri++

                        escape = true</span>
                case '"':<span class="cov0" title="0">
                        if zl.commt </span><span class="cov0" title="0">{
                                com[comi] = x
                                comi++
                                break</span>
                        }

                        <span class="cov0" title="0">if escape </span><span class="cov0" title="0">{
                                str[stri] = x
                                stri++

                                escape = false
                                break</span>
                        }

                        <span class="cov0" title="0">zl.space = false

                        // send previous gathered text and the quote
                        var retL lex
                        if stri != 0 </span><span class="cov0" title="0">{
                                l.value = zString
                                l.token = string(str[:stri])

                                retL = *l
                        }</span>

                        // send quote itself as separate token
                        <span class="cov0" title="0">l.value = zQuote
                        l.token = "\""

                        zl.quote = !zl.quote

                        if retL != (lex{}) </span><span class="cov0" title="0">{
                                zl.nextL = true
                                return retL, true
                        }</span>

                        <span class="cov0" title="0">return *l, true</span>
                case '(', ')':<span class="cov0" title="0">
                        if zl.commt </span><span class="cov0" title="0">{
                                com[comi] = x
                                comi++
                                break</span>
                        }

                        <span class="cov0" title="0">if escape || zl.quote </span><span class="cov0" title="0">{
                                // Inside quotes or escaped this is legal.
                                str[stri] = x
                                stri++

                                escape = false
                                break</span>
                        }

                        <span class="cov0" title="0">switch x </span>{
                        case ')':<span class="cov0" title="0">
                                zl.brace--

                                if zl.brace &lt; 0 </span><span class="cov0" title="0">{
                                        l.token = "extra closing brace"
                                        l.err = true
                                        return *l, true
                                }</span>
                        case '(':<span class="cov0" title="0">
                                zl.brace++</span>
                        }
                default:<span class="cov8" title="1">
                        escape = false

                        if zl.commt </span><span class="cov0" title="0">{
                                com[comi] = x
                                comi++
                                break</span>
                        }

                        <span class="cov8" title="1">str[stri] = x
                        stri++

                        zl.space = false</span>
                }
        }

        <span class="cov8" title="1">if zl.readErr != nil &amp;&amp; zl.readErr != io.EOF </span><span class="cov0" title="0">{
                // Don't return any tokens after a read error occurs.
                return lex{value: zEOF}, false
        }</span>

        <span class="cov8" title="1">var retL lex
        if stri &gt; 0 </span><span class="cov8" title="1">{
                // Send remainder of str
                l.value = zString
                l.token = string(str[:stri])
                retL = *l

                if comi &lt;= 0 </span><span class="cov8" title="1">{
                        return retL, true
                }</span>
        }

        <span class="cov8" title="1">if comi &gt; 0 </span><span class="cov0" title="0">{
                // Send remainder of com
                l.value = zNewline
                l.token = "\n"
                zl.comment = string(com[:comi])

                if retL != (lex{}) </span><span class="cov0" title="0">{
                        zl.nextL = true
                        return retL, true
                }</span>

                <span class="cov0" title="0">return *l, true</span>
        }

        <span class="cov8" title="1">if zl.brace != 0 </span><span class="cov0" title="0">{
                l.token = "unbalanced brace"
                l.err = true
                return *l, true
        }</span>

        <span class="cov8" title="1">return lex{value: zEOF}, false</span>
}

func (zl *zlexer) Comment() string <span class="cov0" title="0">{
        if zl.l.err </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return zl.comment</span>
}

// Extract the class number from CLASSxx
func classToInt(token string) (uint16, bool) <span class="cov0" title="0">{
        offset := 5
        if len(token) &lt; offset+1 </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov0" title="0">class, err := strconv.ParseUint(token[offset:], 10, 16)
        if err != nil </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov0" title="0">return uint16(class), true</span>
}

// Extract the rr number from TYPExxx
func typeToInt(token string) (uint16, bool) <span class="cov0" title="0">{
        offset := 4
        if len(token) &lt; offset+1 </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov0" title="0">typ, err := strconv.ParseUint(token[offset:], 10, 16)
        if err != nil </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov0" title="0">return uint16(typ), true</span>
}

func toAbsoluteName(name, origin string) (absolute string, ok bool) <span class="cov8" title="1">{
        // check for an explicit origin reference
        if name == "@" </span><span class="cov0" title="0">{
                // require a nonempty origin
                if origin == "" </span><span class="cov0" title="0">{
                        return "", false
                }</span>
                <span class="cov0" title="0">return origin, true</span>
        }

        // require a valid domain name
        <span class="cov8" title="1">_, ok = dns.IsDomainName(name)
        if !ok || name == "" </span><span class="cov0" title="0">{
                return "", false
        }</span>

        // check if name is already absolute
        <span class="cov8" title="1">if dns.IsFqdn(name) </span><span class="cov8" title="1">{
                return name, true
        }</span>

        // require a nonempty origin
        <span class="cov0" title="0">if origin == "" </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">return appendOrigin(name, origin), true</span>
}

func appendOrigin(name, origin string) string <span class="cov0" title="0">{
        if origin == "." </span><span class="cov0" title="0">{
                return name + origin
        }</span>
        <span class="cov0" title="0">return name + "." + origin</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
