/*
 * Copyright (c) 2025 Johan Stenstam, johani@johani.org
 *
 * Background worker for automatic DNSSEC key state transitions
 */

package kdc

import (
	"context"
	"fmt"
	"log"
	"time"
)

// KeyStateWorker runs periodic checks for automatic state transitions
func KeyStateWorker(ctx context.Context, kdcDB *KdcDB, conf *KdcConf) error {
	ticker := time.NewTicker(1 * time.Minute) // Check every minute
	defer ticker.Stop()

	log.Printf("KDC: KeyStateWorker started (check interval: 1 minute)")

	for {
		select {
		case <-ctx.Done():
			log.Printf("KDC: KeyStateWorker stopping (context cancelled)")
			return nil
		case <-ticker.C:
			if err := checkAndTransitionKeys(kdcDB, conf); err != nil {
				log.Printf("KDC: Error in key state transition check: %v", err)
			}
		}
	}
}

// checkAndTransitionKeys checks for keys that need automatic state transitions
func checkAndTransitionKeys(kdcDB *KdcDB, conf *KdcConf) error {
	now := time.Now()

	// Check published -> standby transition
	if conf.PublishTime > 0 {
		publishedKeys, err := kdcDB.GetKeysByState("", KeyStatePublished)
		if err != nil {
			log.Printf("KDC: Error getting published keys: %v", err)
		} else {
			for _, key := range publishedKeys {
				if key.PublishedAt != nil {
					elapsed := now.Sub(*key.PublishedAt)
					if elapsed >= conf.PublishTime {
						log.Printf("KDC: Auto-transitioning key %s from published to standby (elapsed: %v)", key.ID, elapsed)
						if err := kdcDB.UpdateKeyState(key.ZoneName, key.ID, KeyStateStandby); err != nil {
							log.Printf("KDC: Error transitioning key %s: %v", key.ID, err)
						} else {
							log.Printf("KDC: Successfully transitioned key %s to standby", key.ID)
						}
					}
				}
			}
		}
	}

	// Check retired -> removed transition
	if conf.RetireTime > 0 {
		retiredKeys, err := kdcDB.GetKeysByState("", KeyStateRetired)
		if err != nil {
			log.Printf("KDC: Error getting retired keys: %v", err)
		} else {
			for _, key := range retiredKeys {
				if key.RetiredAt != nil {
					elapsed := now.Sub(*key.RetiredAt)
					if elapsed >= conf.RetireTime {
						log.Printf("KDC: Auto-transitioning key %s from retired to removed (elapsed: %v)", key.ID, elapsed)
						if err := kdcDB.UpdateKeyState(key.ZoneName, key.ID, KeyStateRemoved); err != nil {
							log.Printf("KDC: Error transitioning key %s: %v", key.ID, err)
						} else {
							log.Printf("KDC: Successfully transitioned key %s to removed", key.ID)
						}
					}
				}
			}
		}
	}

	// Maintain standby key count per zone
	if conf.StandbyKeyCount > 0 {
		if err := maintainStandbyKeyCount(kdcDB, conf); err != nil {
			log.Printf("KDC: Error maintaining standby key count: %v", err)
		}
	}

	// Ensure each zone has an active KSK
	if err := ensureActiveKSK(kdcDB, conf); err != nil {
		log.Printf("KDC: Error ensuring active KSK: %v", err)
	}

	// Garbage collect completed distributions older than 5 minutes
	if err := kdcDB.GarbageCollectCompletedDistributions(5 * time.Minute); err != nil {
		log.Printf("KDC: Error garbage collecting completed distributions: %v", err)
	}

	return nil
}

// maintainStandbyKeyCount ensures each zone has the configured number of standby ZSKs
// If a zone has fewer than standby_key_count standby keys and no published keys,
// it generates a new ZSK and immediately sets it to published state
func maintainStandbyKeyCount(kdcDB *KdcDB, conf *KdcConf) error {
	// Get all active zones
	zones, err := kdcDB.GetAllZones()
	if err != nil {
		return fmt.Errorf("failed to get zones: %v", err)
	}

	for _, zone := range zones {
		if !zone.Active {
			continue // Skip inactive zones
		}

		// Get all keys for this zone
		keys, err := kdcDB.GetDNSSECKeysForZone(zone.Name)
		if err != nil {
			log.Printf("KDC: Error getting keys for zone %s: %v", zone.Name, err)
			continue
		}

		// Count standby and published ZSKs
		standbyCount := 0
		publishedCount := 0
		for _, key := range keys {
			if key.KeyType == KeyTypeZSK {
				if key.State == KeyStateStandby {
					standbyCount++
				} else if key.State == KeyStatePublished {
					publishedCount++
				}
			}
		}

		// If we have fewer than required standby keys and no published keys to promote,
		// generate a new ZSK and set it to published immediately
		if standbyCount < conf.StandbyKeyCount && publishedCount == 0 {
			needed := conf.StandbyKeyCount - standbyCount
			log.Printf("KDC: Zone %s has %d standby ZSKs (need %d), no published keys. Generating %d new ZSK(s)...",
				zone.Name, standbyCount, conf.StandbyKeyCount, needed)

			for i := 0; i < needed; i++ {
				// Generate a new ZSK
				algorithm := conf.DefaultAlgorithm
				if algorithm == 0 {
					algorithm = 15 // Default to ED25519 if not configured
				}

				key, err := kdcDB.GenerateDNSSECKey(zone.Name, KeyTypeZSK, algorithm,
					fmt.Sprintf("autogenerated at %s", time.Now().Format("2006-01-02 15:04:05")))
				if err != nil {
					log.Printf("KDC: Error generating ZSK for zone %s: %v", zone.Name, err)
					continue
				}

				// Store the key in database (initially in 'created' state)
				if err := kdcDB.AddDNSSECKey(key); err != nil {
					log.Printf("KDC: Error storing generated ZSK for zone %s: %v", zone.Name, err)
					continue
				}

				// Immediately transition to published state (will auto-transition to standby after publish_time)
				if err := kdcDB.UpdateKeyState(zone.Name, key.ID, KeyStatePublished); err != nil {
					log.Printf("KDC: Error setting generated ZSK %s to published state: %v", key.ID, err)
				} else {
					log.Printf("KDC: Successfully generated and published new ZSK %s for zone %s", key.ID, zone.Name)
				}
			}
		}
	}

	return nil
}

// ensureActiveKSK ensures each active zone has at least one active KSK
// If no active KSK exists, it generates a new KSK, publishes it, and transitions it directly to active
func ensureActiveKSK(kdcDB *KdcDB, conf *KdcConf) error {
	// Get all active zones
	zones, err := kdcDB.GetAllZones()
	if err != nil {
		return fmt.Errorf("failed to get zones: %v", err)
	}

	for _, zone := range zones {
		if !zone.Active {
			continue // Skip inactive zones
		}

		// Get all keys for this zone
		keys, err := kdcDB.GetDNSSECKeysForZone(zone.Name)
		if err != nil {
			log.Printf("KDC: Error getting keys for zone %s: %v", zone.Name, err)
			continue
		}

		// Check if there's an active KSK
		hasActiveKSK := false
		for _, key := range keys {
			if key.KeyType == KeyTypeKSK && IsActiveKeyState(key.State) {
				hasActiveKSK = true
				break
			}
		}

		if !hasActiveKSK {
			log.Printf("KDC: Zone %s has no active KSK. Generating and activating new KSK...", zone.Name)

			// Generate a new KSK
			algorithm := conf.DefaultAlgorithm
			if algorithm == 0 {
				algorithm = 15 // Default to ED25519 if not configured
			}

			key, err := kdcDB.GenerateDNSSECKey(zone.Name, KeyTypeKSK, algorithm,
				fmt.Sprintf("autogenerated at %s", time.Now().Format("2006-01-02 15:04:05")))
			if err != nil {
				log.Printf("KDC: Error generating KSK for zone %s: %v", zone.Name, err)
				continue
			}

			// Store the key in database (initially in 'created' state)
			if err := kdcDB.AddDNSSECKey(key); err != nil {
				log.Printf("KDC: Error storing generated KSK for zone %s: %v", zone.Name, err)
				continue
			}

			// First transition to published (sets published_at timestamp)
			if err := kdcDB.UpdateKeyState(zone.Name, key.ID, KeyStatePublished); err != nil {
				log.Printf("KDC: Error setting generated KSK %s to published state: %v", key.ID, err)
				continue
			}

			// Immediately transition to active (KSKs don't need to go through standby)
			if err := kdcDB.UpdateKeyState(zone.Name, key.ID, KeyStateActive); err != nil {
				log.Printf("KDC: Error setting generated KSK %s to active state: %v", key.ID, err)
			} else {
				log.Printf("KDC: Successfully generated and activated new KSK %s for zone %s", key.ID, zone.Name)
			}
		}
	}

	return nil
}

